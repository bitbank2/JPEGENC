// SPDX-FileCopyrightText: 2021 Larry Bank <bitbank@pobox.com>
// SPDX-License-Identifier: Apache-2.0
//
// JPEG Encoder
//
// Arduino port started 7/22/2021
// Original JPEG code written 20+ years ago :)
// The goal of this code is to encode JPEG images on embedded systems
//
// Copyright 2021 BitBank Software, Inc. All Rights Reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//    http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//===========================================================================
//
// Returns the magnitude and fixes negative values for JPEG encoding
// Upper 16 bits is the new delta value, lower 16 is the magnitude
const uint32_t ulMagnitudeFix[2048] PROGMEM = {
    0x03ff000b, 0x0000000a, 0x0001000a, 0x0002000a, 0x0003000a, 0x0004000a, 0x0005000a, 0x0006000a,
    0x0007000a, 0x0008000a, 0x0009000a, 0x000a000a, 0x000b000a, 0x000c000a, 0x000d000a, 0x000e000a,
    0x000f000a, 0x0010000a, 0x0011000a, 0x0012000a, 0x0013000a, 0x0014000a, 0x0015000a, 0x0016000a,
    0x0017000a, 0x0018000a, 0x0019000a, 0x001a000a, 0x001b000a, 0x001c000a, 0x001d000a, 0x001e000a,
    0x001f000a, 0x0020000a, 0x0021000a, 0x0022000a, 0x0023000a, 0x0024000a, 0x0025000a, 0x0026000a,
    0x0027000a, 0x0028000a, 0x0029000a, 0x002a000a, 0x002b000a, 0x002c000a, 0x002d000a, 0x002e000a,
    0x002f000a, 0x0030000a, 0x0031000a, 0x0032000a, 0x0033000a, 0x0034000a, 0x0035000a, 0x0036000a,
    0x0037000a, 0x0038000a, 0x0039000a, 0x003a000a, 0x003b000a, 0x003c000a, 0x003d000a, 0x003e000a,
    0x003f000a, 0x0040000a, 0x0041000a, 0x0042000a, 0x0043000a, 0x0044000a, 0x0045000a, 0x0046000a,
    0x0047000a, 0x0048000a, 0x0049000a, 0x004a000a, 0x004b000a, 0x004c000a, 0x004d000a, 0x004e000a,
    0x004f000a, 0x0050000a, 0x0051000a, 0x0052000a, 0x0053000a, 0x0054000a, 0x0055000a, 0x0056000a,
    0x0057000a, 0x0058000a, 0x0059000a, 0x005a000a, 0x005b000a, 0x005c000a, 0x005d000a, 0x005e000a,
    0x005f000a, 0x0060000a, 0x0061000a, 0x0062000a, 0x0063000a, 0x0064000a, 0x0065000a, 0x0066000a,
    0x0067000a, 0x0068000a, 0x0069000a, 0x006a000a, 0x006b000a, 0x006c000a, 0x006d000a, 0x006e000a,
    0x006f000a, 0x0070000a, 0x0071000a, 0x0072000a, 0x0073000a, 0x0074000a, 0x0075000a, 0x0076000a,
    0x0077000a, 0x0078000a, 0x0079000a, 0x007a000a, 0x007b000a, 0x007c000a, 0x007d000a, 0x007e000a,
    0x007f000a, 0x0080000a, 0x0081000a, 0x0082000a, 0x0083000a, 0x0084000a, 0x0085000a, 0x0086000a,
    0x0087000a, 0x0088000a, 0x0089000a, 0x008a000a, 0x008b000a, 0x008c000a, 0x008d000a, 0x008e000a,
    0x008f000a, 0x0090000a, 0x0091000a, 0x0092000a, 0x0093000a, 0x0094000a, 0x0095000a, 0x0096000a,
    0x0097000a, 0x0098000a, 0x0099000a, 0x009a000a, 0x009b000a, 0x009c000a, 0x009d000a, 0x009e000a,
    0x009f000a, 0x00a0000a, 0x00a1000a, 0x00a2000a, 0x00a3000a, 0x00a4000a, 0x00a5000a, 0x00a6000a,
    0x00a7000a, 0x00a8000a, 0x00a9000a, 0x00aa000a, 0x00ab000a, 0x00ac000a, 0x00ad000a, 0x00ae000a,
    0x00af000a, 0x00b0000a, 0x00b1000a, 0x00b2000a, 0x00b3000a, 0x00b4000a, 0x00b5000a, 0x00b6000a,
    0x00b7000a, 0x00b8000a, 0x00b9000a, 0x00ba000a, 0x00bb000a, 0x00bc000a, 0x00bd000a, 0x00be000a,
    0x00bf000a, 0x00c0000a, 0x00c1000a, 0x00c2000a, 0x00c3000a, 0x00c4000a, 0x00c5000a, 0x00c6000a,
    0x00c7000a, 0x00c8000a, 0x00c9000a, 0x00ca000a, 0x00cb000a, 0x00cc000a, 0x00cd000a, 0x00ce000a,
    0x00cf000a, 0x00d0000a, 0x00d1000a, 0x00d2000a, 0x00d3000a, 0x00d4000a, 0x00d5000a, 0x00d6000a,
    0x00d7000a, 0x00d8000a, 0x00d9000a, 0x00da000a, 0x00db000a, 0x00dc000a, 0x00dd000a, 0x00de000a,
    0x00df000a, 0x00e0000a, 0x00e1000a, 0x00e2000a, 0x00e3000a, 0x00e4000a, 0x00e5000a, 0x00e6000a,
    0x00e7000a, 0x00e8000a, 0x00e9000a, 0x00ea000a, 0x00eb000a, 0x00ec000a, 0x00ed000a, 0x00ee000a,
    0x00ef000a, 0x00f0000a, 0x00f1000a, 0x00f2000a, 0x00f3000a, 0x00f4000a, 0x00f5000a, 0x00f6000a,
    0x00f7000a, 0x00f8000a, 0x00f9000a, 0x00fa000a, 0x00fb000a, 0x00fc000a, 0x00fd000a, 0x00fe000a,
    0x00ff000a, 0x0100000a, 0x0101000a, 0x0102000a, 0x0103000a, 0x0104000a, 0x0105000a, 0x0106000a,
    0x0107000a, 0x0108000a, 0x0109000a, 0x010a000a, 0x010b000a, 0x010c000a, 0x010d000a, 0x010e000a,
    0x010f000a, 0x0110000a, 0x0111000a, 0x0112000a, 0x0113000a, 0x0114000a, 0x0115000a, 0x0116000a,
    0x0117000a, 0x0118000a, 0x0119000a, 0x011a000a, 0x011b000a, 0x011c000a, 0x011d000a, 0x011e000a,
    0x011f000a, 0x0120000a, 0x0121000a, 0x0122000a, 0x0123000a, 0x0124000a, 0x0125000a, 0x0126000a,
    0x0127000a, 0x0128000a, 0x0129000a, 0x012a000a, 0x012b000a, 0x012c000a, 0x012d000a, 0x012e000a,
    0x012f000a, 0x0130000a, 0x0131000a, 0x0132000a, 0x0133000a, 0x0134000a, 0x0135000a, 0x0136000a,
    0x0137000a, 0x0138000a, 0x0139000a, 0x013a000a, 0x013b000a, 0x013c000a, 0x013d000a, 0x013e000a,
    0x013f000a, 0x0140000a, 0x0141000a, 0x0142000a, 0x0143000a, 0x0144000a, 0x0145000a, 0x0146000a,
    0x0147000a, 0x0148000a, 0x0149000a, 0x014a000a, 0x014b000a, 0x014c000a, 0x014d000a, 0x014e000a,
    0x014f000a, 0x0150000a, 0x0151000a, 0x0152000a, 0x0153000a, 0x0154000a, 0x0155000a, 0x0156000a,
    0x0157000a, 0x0158000a, 0x0159000a, 0x015a000a, 0x015b000a, 0x015c000a, 0x015d000a, 0x015e000a,
    0x015f000a, 0x0160000a, 0x0161000a, 0x0162000a, 0x0163000a, 0x0164000a, 0x0165000a, 0x0166000a,
    0x0167000a, 0x0168000a, 0x0169000a, 0x016a000a, 0x016b000a, 0x016c000a, 0x016d000a, 0x016e000a,
    0x016f000a, 0x0170000a, 0x0171000a, 0x0172000a, 0x0173000a, 0x0174000a, 0x0175000a, 0x0176000a,
    0x0177000a, 0x0178000a, 0x0179000a, 0x017a000a, 0x017b000a, 0x017c000a, 0x017d000a, 0x017e000a,
    0x017f000a, 0x0180000a, 0x0181000a, 0x0182000a, 0x0183000a, 0x0184000a, 0x0185000a, 0x0186000a,
    0x0187000a, 0x0188000a, 0x0189000a, 0x018a000a, 0x018b000a, 0x018c000a, 0x018d000a, 0x018e000a,
    0x018f000a, 0x0190000a, 0x0191000a, 0x0192000a, 0x0193000a, 0x0194000a, 0x0195000a, 0x0196000a,
    0x0197000a, 0x0198000a, 0x0199000a, 0x019a000a, 0x019b000a, 0x019c000a, 0x019d000a, 0x019e000a,
    0x019f000a, 0x01a0000a, 0x01a1000a, 0x01a2000a, 0x01a3000a, 0x01a4000a, 0x01a5000a, 0x01a6000a,
    0x01a7000a, 0x01a8000a, 0x01a9000a, 0x01aa000a, 0x01ab000a, 0x01ac000a, 0x01ad000a, 0x01ae000a,
    0x01af000a, 0x01b0000a, 0x01b1000a, 0x01b2000a, 0x01b3000a, 0x01b4000a, 0x01b5000a, 0x01b6000a,
    0x01b7000a, 0x01b8000a, 0x01b9000a, 0x01ba000a, 0x01bb000a, 0x01bc000a, 0x01bd000a, 0x01be000a,
    0x01bf000a, 0x01c0000a, 0x01c1000a, 0x01c2000a, 0x01c3000a, 0x01c4000a, 0x01c5000a, 0x01c6000a,
    0x01c7000a, 0x01c8000a, 0x01c9000a, 0x01ca000a, 0x01cb000a, 0x01cc000a, 0x01cd000a, 0x01ce000a,
    0x01cf000a, 0x01d0000a, 0x01d1000a, 0x01d2000a, 0x01d3000a, 0x01d4000a, 0x01d5000a, 0x01d6000a,
    0x01d7000a, 0x01d8000a, 0x01d9000a, 0x01da000a, 0x01db000a, 0x01dc000a, 0x01dd000a, 0x01de000a,
    0x01df000a, 0x01e0000a, 0x01e1000a, 0x01e2000a, 0x01e3000a, 0x01e4000a, 0x01e5000a, 0x01e6000a,
    0x01e7000a, 0x01e8000a, 0x01e9000a, 0x01ea000a, 0x01eb000a, 0x01ec000a, 0x01ed000a, 0x01ee000a,
    0x01ef000a, 0x01f0000a, 0x01f1000a, 0x01f2000a, 0x01f3000a, 0x01f4000a, 0x01f5000a, 0x01f6000a,
    0x01f7000a, 0x01f8000a, 0x01f9000a, 0x01fa000a, 0x01fb000a, 0x01fc000a, 0x01fd000a, 0x01fe000a,
    0x01ff000a, 0x00000009, 0x00010009, 0x00020009, 0x00030009, 0x00040009, 0x00050009, 0x00060009,
    0x00070009, 0x00080009, 0x00090009, 0x000a0009, 0x000b0009, 0x000c0009, 0x000d0009, 0x000e0009,
    0x000f0009, 0x00100009, 0x00110009, 0x00120009, 0x00130009, 0x00140009, 0x00150009, 0x00160009,
    0x00170009, 0x00180009, 0x00190009, 0x001a0009, 0x001b0009, 0x001c0009, 0x001d0009, 0x001e0009,
    0x001f0009, 0x00200009, 0x00210009, 0x00220009, 0x00230009, 0x00240009, 0x00250009, 0x00260009,
    0x00270009, 0x00280009, 0x00290009, 0x002a0009, 0x002b0009, 0x002c0009, 0x002d0009, 0x002e0009,
    0x002f0009, 0x00300009, 0x00310009, 0x00320009, 0x00330009, 0x00340009, 0x00350009, 0x00360009,
    0x00370009, 0x00380009, 0x00390009, 0x003a0009, 0x003b0009, 0x003c0009, 0x003d0009, 0x003e0009,
    0x003f0009, 0x00400009, 0x00410009, 0x00420009, 0x00430009, 0x00440009, 0x00450009, 0x00460009,
    0x00470009, 0x00480009, 0x00490009, 0x004a0009, 0x004b0009, 0x004c0009, 0x004d0009, 0x004e0009,
    0x004f0009, 0x00500009, 0x00510009, 0x00520009, 0x00530009, 0x00540009, 0x00550009, 0x00560009,
    0x00570009, 0x00580009, 0x00590009, 0x005a0009, 0x005b0009, 0x005c0009, 0x005d0009, 0x005e0009,
    0x005f0009, 0x00600009, 0x00610009, 0x00620009, 0x00630009, 0x00640009, 0x00650009, 0x00660009,
    0x00670009, 0x00680009, 0x00690009, 0x006a0009, 0x006b0009, 0x006c0009, 0x006d0009, 0x006e0009,
    0x006f0009, 0x00700009, 0x00710009, 0x00720009, 0x00730009, 0x00740009, 0x00750009, 0x00760009,
    0x00770009, 0x00780009, 0x00790009, 0x007a0009, 0x007b0009, 0x007c0009, 0x007d0009, 0x007e0009,
    0x007f0009, 0x00800009, 0x00810009, 0x00820009, 0x00830009, 0x00840009, 0x00850009, 0x00860009,
    0x00870009, 0x00880009, 0x00890009, 0x008a0009, 0x008b0009, 0x008c0009, 0x008d0009, 0x008e0009,
    0x008f0009, 0x00900009, 0x00910009, 0x00920009, 0x00930009, 0x00940009, 0x00950009, 0x00960009,
    0x00970009, 0x00980009, 0x00990009, 0x009a0009, 0x009b0009, 0x009c0009, 0x009d0009, 0x009e0009,
    0x009f0009, 0x00a00009, 0x00a10009, 0x00a20009, 0x00a30009, 0x00a40009, 0x00a50009, 0x00a60009,
    0x00a70009, 0x00a80009, 0x00a90009, 0x00aa0009, 0x00ab0009, 0x00ac0009, 0x00ad0009, 0x00ae0009,
    0x00af0009, 0x00b00009, 0x00b10009, 0x00b20009, 0x00b30009, 0x00b40009, 0x00b50009, 0x00b60009,
    0x00b70009, 0x00b80009, 0x00b90009, 0x00ba0009, 0x00bb0009, 0x00bc0009, 0x00bd0009, 0x00be0009,
    0x00bf0009, 0x00c00009, 0x00c10009, 0x00c20009, 0x00c30009, 0x00c40009, 0x00c50009, 0x00c60009,
    0x00c70009, 0x00c80009, 0x00c90009, 0x00ca0009, 0x00cb0009, 0x00cc0009, 0x00cd0009, 0x00ce0009,
    0x00cf0009, 0x00d00009, 0x00d10009, 0x00d20009, 0x00d30009, 0x00d40009, 0x00d50009, 0x00d60009,
    0x00d70009, 0x00d80009, 0x00d90009, 0x00da0009, 0x00db0009, 0x00dc0009, 0x00dd0009, 0x00de0009,
    0x00df0009, 0x00e00009, 0x00e10009, 0x00e20009, 0x00e30009, 0x00e40009, 0x00e50009, 0x00e60009,
    0x00e70009, 0x00e80009, 0x00e90009, 0x00ea0009, 0x00eb0009, 0x00ec0009, 0x00ed0009, 0x00ee0009,
    0x00ef0009, 0x00f00009, 0x00f10009, 0x00f20009, 0x00f30009, 0x00f40009, 0x00f50009, 0x00f60009,
    0x00f70009, 0x00f80009, 0x00f90009, 0x00fa0009, 0x00fb0009, 0x00fc0009, 0x00fd0009, 0x00fe0009,
    0x00ff0009, 0x00000008, 0x00010008, 0x00020008, 0x00030008, 0x00040008, 0x00050008, 0x00060008,
    0x00070008, 0x00080008, 0x00090008, 0x000a0008, 0x000b0008, 0x000c0008, 0x000d0008, 0x000e0008,
    0x000f0008, 0x00100008, 0x00110008, 0x00120008, 0x00130008, 0x00140008, 0x00150008, 0x00160008,
    0x00170008, 0x00180008, 0x00190008, 0x001a0008, 0x001b0008, 0x001c0008, 0x001d0008, 0x001e0008,
    0x001f0008, 0x00200008, 0x00210008, 0x00220008, 0x00230008, 0x00240008, 0x00250008, 0x00260008,
    0x00270008, 0x00280008, 0x00290008, 0x002a0008, 0x002b0008, 0x002c0008, 0x002d0008, 0x002e0008,
    0x002f0008, 0x00300008, 0x00310008, 0x00320008, 0x00330008, 0x00340008, 0x00350008, 0x00360008,
    0x00370008, 0x00380008, 0x00390008, 0x003a0008, 0x003b0008, 0x003c0008, 0x003d0008, 0x003e0008,
    0x003f0008, 0x00400008, 0x00410008, 0x00420008, 0x00430008, 0x00440008, 0x00450008, 0x00460008,
    0x00470008, 0x00480008, 0x00490008, 0x004a0008, 0x004b0008, 0x004c0008, 0x004d0008, 0x004e0008,
    0x004f0008, 0x00500008, 0x00510008, 0x00520008, 0x00530008, 0x00540008, 0x00550008, 0x00560008,
    0x00570008, 0x00580008, 0x00590008, 0x005a0008, 0x005b0008, 0x005c0008, 0x005d0008, 0x005e0008,
    0x005f0008, 0x00600008, 0x00610008, 0x00620008, 0x00630008, 0x00640008, 0x00650008, 0x00660008,
    0x00670008, 0x00680008, 0x00690008, 0x006a0008, 0x006b0008, 0x006c0008, 0x006d0008, 0x006e0008,
    0x006f0008, 0x00700008, 0x00710008, 0x00720008, 0x00730008, 0x00740008, 0x00750008, 0x00760008,
    0x00770008, 0x00780008, 0x00790008, 0x007a0008, 0x007b0008, 0x007c0008, 0x007d0008, 0x007e0008,
    0x007f0008, 0x00000007, 0x00010007, 0x00020007, 0x00030007, 0x00040007, 0x00050007, 0x00060007,
    0x00070007, 0x00080007, 0x00090007, 0x000a0007, 0x000b0007, 0x000c0007, 0x000d0007, 0x000e0007,
    0x000f0007, 0x00100007, 0x00110007, 0x00120007, 0x00130007, 0x00140007, 0x00150007, 0x00160007,
    0x00170007, 0x00180007, 0x00190007, 0x001a0007, 0x001b0007, 0x001c0007, 0x001d0007, 0x001e0007,
    0x001f0007, 0x00200007, 0x00210007, 0x00220007, 0x00230007, 0x00240007, 0x00250007, 0x00260007,
    0x00270007, 0x00280007, 0x00290007, 0x002a0007, 0x002b0007, 0x002c0007, 0x002d0007, 0x002e0007,
    0x002f0007, 0x00300007, 0x00310007, 0x00320007, 0x00330007, 0x00340007, 0x00350007, 0x00360007,
    0x00370007, 0x00380007, 0x00390007, 0x003a0007, 0x003b0007, 0x003c0007, 0x003d0007, 0x003e0007,
    0x003f0007, 0x00000006, 0x00010006, 0x00020006, 0x00030006, 0x00040006, 0x00050006, 0x00060006,
    0x00070006, 0x00080006, 0x00090006, 0x000a0006, 0x000b0006, 0x000c0006, 0x000d0006, 0x000e0006,
    0x000f0006, 0x00100006, 0x00110006, 0x00120006, 0x00130006, 0x00140006, 0x00150006, 0x00160006,
    0x00170006, 0x00180006, 0x00190006, 0x001a0006, 0x001b0006, 0x001c0006, 0x001d0006, 0x001e0006,
    0x001f0006, 0x00000005, 0x00010005, 0x00020005, 0x00030005, 0x00040005, 0x00050005, 0x00060005,
    0x00070005, 0x00080005, 0x00090005, 0x000a0005, 0x000b0005, 0x000c0005, 0x000d0005, 0x000e0005,
    0x000f0005, 0x00000004, 0x00010004, 0x00020004, 0x00030004, 0x00040004, 0x00050004, 0x00060004,
    0x00070004, 0x00000003, 0x00010003, 0x00020003, 0x00030003, 0x00000002, 0x00010002, 0x00000001,
    0x00000000, 0x00010001, 0x00020002, 0x00030002, 0x00040003, 0x00050003, 0x00060003, 0x00070003,
    0x00080004, 0x00090004, 0x000a0004, 0x000b0004, 0x000c0004, 0x000d0004, 0x000e0004, 0x000f0004,
    0x00100005, 0x00110005, 0x00120005, 0x00130005, 0x00140005, 0x00150005, 0x00160005, 0x00170005,
    0x00180005, 0x00190005, 0x001a0005, 0x001b0005, 0x001c0005, 0x001d0005, 0x001e0005, 0x001f0005,
    0x00200006, 0x00210006, 0x00220006, 0x00230006, 0x00240006, 0x00250006, 0x00260006, 0x00270006,
    0x00280006, 0x00290006, 0x002a0006, 0x002b0006, 0x002c0006, 0x002d0006, 0x002e0006, 0x002f0006,
    0x00300006, 0x00310006, 0x00320006, 0x00330006, 0x00340006, 0x00350006, 0x00360006, 0x00370006,
    0x00380006, 0x00390006, 0x003a0006, 0x003b0006, 0x003c0006, 0x003d0006, 0x003e0006, 0x003f0006,
    0x00400007, 0x00410007, 0x00420007, 0x00430007, 0x00440007, 0x00450007, 0x00460007, 0x00470007,
    0x00480007, 0x00490007, 0x004a0007, 0x004b0007, 0x004c0007, 0x004d0007, 0x004e0007, 0x004f0007,
    0x00500007, 0x00510007, 0x00520007, 0x00530007, 0x00540007, 0x00550007, 0x00560007, 0x00570007,
    0x00580007, 0x00590007, 0x005a0007, 0x005b0007, 0x005c0007, 0x005d0007, 0x005e0007, 0x005f0007,
    0x00600007, 0x00610007, 0x00620007, 0x00630007, 0x00640007, 0x00650007, 0x00660007, 0x00670007,
    0x00680007, 0x00690007, 0x006a0007, 0x006b0007, 0x006c0007, 0x006d0007, 0x006e0007, 0x006f0007,
    0x00700007, 0x00710007, 0x00720007, 0x00730007, 0x00740007, 0x00750007, 0x00760007, 0x00770007,
    0x00780007, 0x00790007, 0x007a0007, 0x007b0007, 0x007c0007, 0x007d0007, 0x007e0007, 0x007f0007,
    0x00800008, 0x00810008, 0x00820008, 0x00830008, 0x00840008, 0x00850008, 0x00860008, 0x00870008,
    0x00880008, 0x00890008, 0x008a0008, 0x008b0008, 0x008c0008, 0x008d0008, 0x008e0008, 0x008f0008,
    0x00900008, 0x00910008, 0x00920008, 0x00930008, 0x00940008, 0x00950008, 0x00960008, 0x00970008,
    0x00980008, 0x00990008, 0x009a0008, 0x009b0008, 0x009c0008, 0x009d0008, 0x009e0008, 0x009f0008,
    0x00a00008, 0x00a10008, 0x00a20008, 0x00a30008, 0x00a40008, 0x00a50008, 0x00a60008, 0x00a70008,
    0x00a80008, 0x00a90008, 0x00aa0008, 0x00ab0008, 0x00ac0008, 0x00ad0008, 0x00ae0008, 0x00af0008,
    0x00b00008, 0x00b10008, 0x00b20008, 0x00b30008, 0x00b40008, 0x00b50008, 0x00b60008, 0x00b70008,
    0x00b80008, 0x00b90008, 0x00ba0008, 0x00bb0008, 0x00bc0008, 0x00bd0008, 0x00be0008, 0x00bf0008,
    0x00c00008, 0x00c10008, 0x00c20008, 0x00c30008, 0x00c40008, 0x00c50008, 0x00c60008, 0x00c70008,
    0x00c80008, 0x00c90008, 0x00ca0008, 0x00cb0008, 0x00cc0008, 0x00cd0008, 0x00ce0008, 0x00cf0008,
    0x00d00008, 0x00d10008, 0x00d20008, 0x00d30008, 0x00d40008, 0x00d50008, 0x00d60008, 0x00d70008,
    0x00d80008, 0x00d90008, 0x00da0008, 0x00db0008, 0x00dc0008, 0x00dd0008, 0x00de0008, 0x00df0008,
    0x00e00008, 0x00e10008, 0x00e20008, 0x00e30008, 0x00e40008, 0x00e50008, 0x00e60008, 0x00e70008,
    0x00e80008, 0x00e90008, 0x00ea0008, 0x00eb0008, 0x00ec0008, 0x00ed0008, 0x00ee0008, 0x00ef0008,
    0x00f00008, 0x00f10008, 0x00f20008, 0x00f30008, 0x00f40008, 0x00f50008, 0x00f60008, 0x00f70008,
    0x00f80008, 0x00f90008, 0x00fa0008, 0x00fb0008, 0x00fc0008, 0x00fd0008, 0x00fe0008, 0x00ff0008,
    0x01000009, 0x01010009, 0x01020009, 0x01030009, 0x01040009, 0x01050009, 0x01060009, 0x01070009,
    0x01080009, 0x01090009, 0x010a0009, 0x010b0009, 0x010c0009, 0x010d0009, 0x010e0009, 0x010f0009,
    0x01100009, 0x01110009, 0x01120009, 0x01130009, 0x01140009, 0x01150009, 0x01160009, 0x01170009,
    0x01180009, 0x01190009, 0x011a0009, 0x011b0009, 0x011c0009, 0x011d0009, 0x011e0009, 0x011f0009,
    0x01200009, 0x01210009, 0x01220009, 0x01230009, 0x01240009, 0x01250009, 0x01260009, 0x01270009,
    0x01280009, 0x01290009, 0x012a0009, 0x012b0009, 0x012c0009, 0x012d0009, 0x012e0009, 0x012f0009,
    0x01300009, 0x01310009, 0x01320009, 0x01330009, 0x01340009, 0x01350009, 0x01360009, 0x01370009,
    0x01380009, 0x01390009, 0x013a0009, 0x013b0009, 0x013c0009, 0x013d0009, 0x013e0009, 0x013f0009,
    0x01400009, 0x01410009, 0x01420009, 0x01430009, 0x01440009, 0x01450009, 0x01460009, 0x01470009,
    0x01480009, 0x01490009, 0x014a0009, 0x014b0009, 0x014c0009, 0x014d0009, 0x014e0009, 0x014f0009,
    0x01500009, 0x01510009, 0x01520009, 0x01530009, 0x01540009, 0x01550009, 0x01560009, 0x01570009,
    0x01580009, 0x01590009, 0x015a0009, 0x015b0009, 0x015c0009, 0x015d0009, 0x015e0009, 0x015f0009,
    0x01600009, 0x01610009, 0x01620009, 0x01630009, 0x01640009, 0x01650009, 0x01660009, 0x01670009,
    0x01680009, 0x01690009, 0x016a0009, 0x016b0009, 0x016c0009, 0x016d0009, 0x016e0009, 0x016f0009,
    0x01700009, 0x01710009, 0x01720009, 0x01730009, 0x01740009, 0x01750009, 0x01760009, 0x01770009,
    0x01780009, 0x01790009, 0x017a0009, 0x017b0009, 0x017c0009, 0x017d0009, 0x017e0009, 0x017f0009,
    0x01800009, 0x01810009, 0x01820009, 0x01830009, 0x01840009, 0x01850009, 0x01860009, 0x01870009,
    0x01880009, 0x01890009, 0x018a0009, 0x018b0009, 0x018c0009, 0x018d0009, 0x018e0009, 0x018f0009,
    0x01900009, 0x01910009, 0x01920009, 0x01930009, 0x01940009, 0x01950009, 0x01960009, 0x01970009,
    0x01980009, 0x01990009, 0x019a0009, 0x019b0009, 0x019c0009, 0x019d0009, 0x019e0009, 0x019f0009,
    0x01a00009, 0x01a10009, 0x01a20009, 0x01a30009, 0x01a40009, 0x01a50009, 0x01a60009, 0x01a70009,
    0x01a80009, 0x01a90009, 0x01aa0009, 0x01ab0009, 0x01ac0009, 0x01ad0009, 0x01ae0009, 0x01af0009,
    0x01b00009, 0x01b10009, 0x01b20009, 0x01b30009, 0x01b40009, 0x01b50009, 0x01b60009, 0x01b70009,
    0x01b80009, 0x01b90009, 0x01ba0009, 0x01bb0009, 0x01bc0009, 0x01bd0009, 0x01be0009, 0x01bf0009,
    0x01c00009, 0x01c10009, 0x01c20009, 0x01c30009, 0x01c40009, 0x01c50009, 0x01c60009, 0x01c70009,
    0x01c80009, 0x01c90009, 0x01ca0009, 0x01cb0009, 0x01cc0009, 0x01cd0009, 0x01ce0009, 0x01cf0009,
    0x01d00009, 0x01d10009, 0x01d20009, 0x01d30009, 0x01d40009, 0x01d50009, 0x01d60009, 0x01d70009,
    0x01d80009, 0x01d90009, 0x01da0009, 0x01db0009, 0x01dc0009, 0x01dd0009, 0x01de0009, 0x01df0009,
    0x01e00009, 0x01e10009, 0x01e20009, 0x01e30009, 0x01e40009, 0x01e50009, 0x01e60009, 0x01e70009,
    0x01e80009, 0x01e90009, 0x01ea0009, 0x01eb0009, 0x01ec0009, 0x01ed0009, 0x01ee0009, 0x01ef0009,
    0x01f00009, 0x01f10009, 0x01f20009, 0x01f30009, 0x01f40009, 0x01f50009, 0x01f60009, 0x01f70009,
    0x01f80009, 0x01f90009, 0x01fa0009, 0x01fb0009, 0x01fc0009, 0x01fd0009, 0x01fe0009, 0x01ff0009,
    0x0200000a, 0x0201000a, 0x0202000a, 0x0203000a, 0x0204000a, 0x0205000a, 0x0206000a, 0x0207000a,
    0x0208000a, 0x0209000a, 0x020a000a, 0x020b000a, 0x020c000a, 0x020d000a, 0x020e000a, 0x020f000a,
    0x0210000a, 0x0211000a, 0x0212000a, 0x0213000a, 0x0214000a, 0x0215000a, 0x0216000a, 0x0217000a,
    0x0218000a, 0x0219000a, 0x021a000a, 0x021b000a, 0x021c000a, 0x021d000a, 0x021e000a, 0x021f000a,
    0x0220000a, 0x0221000a, 0x0222000a, 0x0223000a, 0x0224000a, 0x0225000a, 0x0226000a, 0x0227000a,
    0x0228000a, 0x0229000a, 0x022a000a, 0x022b000a, 0x022c000a, 0x022d000a, 0x022e000a, 0x022f000a,
    0x0230000a, 0x0231000a, 0x0232000a, 0x0233000a, 0x0234000a, 0x0235000a, 0x0236000a, 0x0237000a,
    0x0238000a, 0x0239000a, 0x023a000a, 0x023b000a, 0x023c000a, 0x023d000a, 0x023e000a, 0x023f000a,
    0x0240000a, 0x0241000a, 0x0242000a, 0x0243000a, 0x0244000a, 0x0245000a, 0x0246000a, 0x0247000a,
    0x0248000a, 0x0249000a, 0x024a000a, 0x024b000a, 0x024c000a, 0x024d000a, 0x024e000a, 0x024f000a,
    0x0250000a, 0x0251000a, 0x0252000a, 0x0253000a, 0x0254000a, 0x0255000a, 0x0256000a, 0x0257000a,
    0x0258000a, 0x0259000a, 0x025a000a, 0x025b000a, 0x025c000a, 0x025d000a, 0x025e000a, 0x025f000a,
    0x0260000a, 0x0261000a, 0x0262000a, 0x0263000a, 0x0264000a, 0x0265000a, 0x0266000a, 0x0267000a,
    0x0268000a, 0x0269000a, 0x026a000a, 0x026b000a, 0x026c000a, 0x026d000a, 0x026e000a, 0x026f000a,
    0x0270000a, 0x0271000a, 0x0272000a, 0x0273000a, 0x0274000a, 0x0275000a, 0x0276000a, 0x0277000a,
    0x0278000a, 0x0279000a, 0x027a000a, 0x027b000a, 0x027c000a, 0x027d000a, 0x027e000a, 0x027f000a,
    0x0280000a, 0x0281000a, 0x0282000a, 0x0283000a, 0x0284000a, 0x0285000a, 0x0286000a, 0x0287000a,
    0x0288000a, 0x0289000a, 0x028a000a, 0x028b000a, 0x028c000a, 0x028d000a, 0x028e000a, 0x028f000a,
    0x0290000a, 0x0291000a, 0x0292000a, 0x0293000a, 0x0294000a, 0x0295000a, 0x0296000a, 0x0297000a,
    0x0298000a, 0x0299000a, 0x029a000a, 0x029b000a, 0x029c000a, 0x029d000a, 0x029e000a, 0x029f000a,
    0x02a0000a, 0x02a1000a, 0x02a2000a, 0x02a3000a, 0x02a4000a, 0x02a5000a, 0x02a6000a, 0x02a7000a,
    0x02a8000a, 0x02a9000a, 0x02aa000a, 0x02ab000a, 0x02ac000a, 0x02ad000a, 0x02ae000a, 0x02af000a,
    0x02b0000a, 0x02b1000a, 0x02b2000a, 0x02b3000a, 0x02b4000a, 0x02b5000a, 0x02b6000a, 0x02b7000a,
    0x02b8000a, 0x02b9000a, 0x02ba000a, 0x02bb000a, 0x02bc000a, 0x02bd000a, 0x02be000a, 0x02bf000a,
    0x02c0000a, 0x02c1000a, 0x02c2000a, 0x02c3000a, 0x02c4000a, 0x02c5000a, 0x02c6000a, 0x02c7000a,
    0x02c8000a, 0x02c9000a, 0x02ca000a, 0x02cb000a, 0x02cc000a, 0x02cd000a, 0x02ce000a, 0x02cf000a,
    0x02d0000a, 0x02d1000a, 0x02d2000a, 0x02d3000a, 0x02d4000a, 0x02d5000a, 0x02d6000a, 0x02d7000a,
    0x02d8000a, 0x02d9000a, 0x02da000a, 0x02db000a, 0x02dc000a, 0x02dd000a, 0x02de000a, 0x02df000a,
    0x02e0000a, 0x02e1000a, 0x02e2000a, 0x02e3000a, 0x02e4000a, 0x02e5000a, 0x02e6000a, 0x02e7000a,
    0x02e8000a, 0x02e9000a, 0x02ea000a, 0x02eb000a, 0x02ec000a, 0x02ed000a, 0x02ee000a, 0x02ef000a,
    0x02f0000a, 0x02f1000a, 0x02f2000a, 0x02f3000a, 0x02f4000a, 0x02f5000a, 0x02f6000a, 0x02f7000a,
    0x02f8000a, 0x02f9000a, 0x02fa000a, 0x02fb000a, 0x02fc000a, 0x02fd000a, 0x02fe000a, 0x02ff000a,
    0x0300000a, 0x0301000a, 0x0302000a, 0x0303000a, 0x0304000a, 0x0305000a, 0x0306000a, 0x0307000a,
    0x0308000a, 0x0309000a, 0x030a000a, 0x030b000a, 0x030c000a, 0x030d000a, 0x030e000a, 0x030f000a,
    0x0310000a, 0x0311000a, 0x0312000a, 0x0313000a, 0x0314000a, 0x0315000a, 0x0316000a, 0x0317000a,
    0x0318000a, 0x0319000a, 0x031a000a, 0x031b000a, 0x031c000a, 0x031d000a, 0x031e000a, 0x031f000a,
    0x0320000a, 0x0321000a, 0x0322000a, 0x0323000a, 0x0324000a, 0x0325000a, 0x0326000a, 0x0327000a,
    0x0328000a, 0x0329000a, 0x032a000a, 0x032b000a, 0x032c000a, 0x032d000a, 0x032e000a, 0x032f000a,
    0x0330000a, 0x0331000a, 0x0332000a, 0x0333000a, 0x0334000a, 0x0335000a, 0x0336000a, 0x0337000a,
    0x0338000a, 0x0339000a, 0x033a000a, 0x033b000a, 0x033c000a, 0x033d000a, 0x033e000a, 0x033f000a,
    0x0340000a, 0x0341000a, 0x0342000a, 0x0343000a, 0x0344000a, 0x0345000a, 0x0346000a, 0x0347000a,
    0x0348000a, 0x0349000a, 0x034a000a, 0x034b000a, 0x034c000a, 0x034d000a, 0x034e000a, 0x034f000a,
    0x0350000a, 0x0351000a, 0x0352000a, 0x0353000a, 0x0354000a, 0x0355000a, 0x0356000a, 0x0357000a,
    0x0358000a, 0x0359000a, 0x035a000a, 0x035b000a, 0x035c000a, 0x035d000a, 0x035e000a, 0x035f000a,
    0x0360000a, 0x0361000a, 0x0362000a, 0x0363000a, 0x0364000a, 0x0365000a, 0x0366000a, 0x0367000a,
    0x0368000a, 0x0369000a, 0x036a000a, 0x036b000a, 0x036c000a, 0x036d000a, 0x036e000a, 0x036f000a,
    0x0370000a, 0x0371000a, 0x0372000a, 0x0373000a, 0x0374000a, 0x0375000a, 0x0376000a, 0x0377000a,
    0x0378000a, 0x0379000a, 0x037a000a, 0x037b000a, 0x037c000a, 0x037d000a, 0x037e000a, 0x037f000a,
    0x0380000a, 0x0381000a, 0x0382000a, 0x0383000a, 0x0384000a, 0x0385000a, 0x0386000a, 0x0387000a,
    0x0388000a, 0x0389000a, 0x038a000a, 0x038b000a, 0x038c000a, 0x038d000a, 0x038e000a, 0x038f000a,
    0x0390000a, 0x0391000a, 0x0392000a, 0x0393000a, 0x0394000a, 0x0395000a, 0x0396000a, 0x0397000a,
    0x0398000a, 0x0399000a, 0x039a000a, 0x039b000a, 0x039c000a, 0x039d000a, 0x039e000a, 0x039f000a,
    0x03a0000a, 0x03a1000a, 0x03a2000a, 0x03a3000a, 0x03a4000a, 0x03a5000a, 0x03a6000a, 0x03a7000a,
    0x03a8000a, 0x03a9000a, 0x03aa000a, 0x03ab000a, 0x03ac000a, 0x03ad000a, 0x03ae000a, 0x03af000a,
    0x03b0000a, 0x03b1000a, 0x03b2000a, 0x03b3000a, 0x03b4000a, 0x03b5000a, 0x03b6000a, 0x03b7000a,
    0x03b8000a, 0x03b9000a, 0x03ba000a, 0x03bb000a, 0x03bc000a, 0x03bd000a, 0x03be000a, 0x03bf000a,
    0x03c0000a, 0x03c1000a, 0x03c2000a, 0x03c3000a, 0x03c4000a, 0x03c5000a, 0x03c6000a, 0x03c7000a,
    0x03c8000a, 0x03c9000a, 0x03ca000a, 0x03cb000a, 0x03cc000a, 0x03cd000a, 0x03ce000a, 0x03cf000a,
    0x03d0000a, 0x03d1000a, 0x03d2000a, 0x03d3000a, 0x03d4000a, 0x03d5000a, 0x03d6000a, 0x03d7000a,
    0x03d8000a, 0x03d9000a, 0x03da000a, 0x03db000a, 0x03dc000a, 0x03dd000a, 0x03de000a, 0x03df000a,
    0x03e0000a, 0x03e1000a, 0x03e2000a, 0x03e3000a, 0x03e4000a, 0x03e5000a, 0x03e6000a, 0x03e7000a,
    0x03e8000a, 0x03e9000a, 0x03ea000a, 0x03eb000a, 0x03ec000a, 0x03ed000a, 0x03ee000a, 0x03ef000a,
    0x03f0000a, 0x03f1000a, 0x03f2000a, 0x03f3000a, 0x03f4000a, 0x03f5000a, 0x03f6000a, 0x03f7000a,
    0x03f8000a, 0x03f9000a, 0x03fa000a, 0x03fb000a, 0x03fc000a, 0x03fd000a, 0x03fe000a, 0x03ff000a};

const unsigned char cMagnitudes[512] PROGMEM = {0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,
    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9};
// zigzag ordering of DCT coefficients
const unsigned char cZigZag[64] PROGMEM = {0,1,5,6,14,15,27,28,
    2,4,7,13,16,26,29,42,
    3,8,12,17,25,30,41,43,
    9,11,18,24,31,40,44,53,
    10,19,23,32,39,45,52,54,
    20,22,33,38,46,51,55,60,
    21,34,37,47,50,56,59,61,
    35,36,48,49,57,58,62,63};
const unsigned char cZigZag2[64] PROGMEM = {0,1,8,16,9,2,3,10,
    17,24,32,25,18,11,4,5,
    12,19,26,33,40,48,41,34,
    27,20,13,6,7,14,21,28,
    35,42,49,56,57,50,43,36,
    29,22,15,23,30,37,44,51,
    58,59,52,45,38,31,39,46,
    53,60,61,54,47,55,62,63};
//
// Typical DC difference huffman tables for luminance and chrominance
//
const unsigned char huffl_dc[28] PROGMEM = {0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0,
    0,1,2,3,4,5,6,7,8,9,0xa,0xb};
const unsigned char huffcr_dc[28] PROGMEM = {0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
    0,1,2,3,4,5,6,7,8,9,0xa,0xb};
//
// Typical AC difference huffman tables for luminance and chrominance
//
const unsigned char huffl_ac[256] PROGMEM = {0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d,
    1,2,3,0,4,0x11,5,0x12,0x21,0x31,0x41,6,0x13,0x51,0x61,7,
    0x22,0x71,0x14,0x32,0x81,0x91,0xa1,8,0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,
    0x24,0x33,0x62,0x72,0x82,9,0xa,0x16,0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
    0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
    0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
    0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
    0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
    0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,
    0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
    0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
    0xf9,0xfa};
const unsigned char huffcr_ac[256] PROGMEM = {0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77,
    0,1,2,3,0x11,4,5,0x21,0x31,6,0x12,0x41,0x51,7,0x61,0x71,
    0x13,0x22,0x32,0x81,0x8,0x14,0x42,0x91,0xa1,0xb1,0xc1,9,0x23,0x33,0x52,0xf0,
    0x15,0x62,0x72,0xd1,0xa,0x16,0x24,0x34,0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
    0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,
    0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,
    0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
    0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,
    0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,
    0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
    0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
    0xf9,0xfa};
// Sample quantization table which can be divided by 2 or 4 or multiplied by 2
// to give different quality levels
const unsigned char quant_lum[64] PROGMEM =
{16,11,12,14,12,10,16,14,13,14,18,17,16,19,24,
    40,26,24,22,22,24,49,35,37,29,40,58,51,61,60,
    57,51,56,55,64,72,92,78,64,68,87,69,55,56,80,
    109,81,87,95,98,103,104,103,62,77,113,121,112,
    100,120,92,101,103,99};
const unsigned char quant_color[64] PROGMEM =
{17,18,18,24,21,24,47,26,26,47,99,66,56,66,99,99,
    99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99};

const unsigned char quant95_lum[64] PROGMEM =
{ 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01,
    0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x04,
    0x03, 0x02, 0x02, 0x02, 0x02, 0x05, 0x04, 0x04,
    0x03, 0x04, 0x06, 0x05, 0x06, 0x06, 0x06, 0x05,
    0x06, 0x06, 0x06, 0x07, 0x09, 0x08, 0x06, 0x07,
    0x09, 0x07, 0x06, 0x06, 0x08, 0x0b, 0x08, 0x09,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x06, 0x08, 0x0b,
    0x0c, 0x0b, 0x0a, 0x0c, 0x09, 0x0a, 0x0a, 0x0a };
const unsigned char quant95_color[64] PROGMEM =
{ 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x05, 0x03,
    0x03, 0x05, 0x0a, 0x07, 0x06, 0x07, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a };

// For AA&N IDCT method, multipliers are equal to quantization
// coefficients scaled by scalefactor[row]*scalefactor[col], where
// scalefactor[0] = 1
// scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
// For integer operation, the multiplier table is to be scaled by
// IFAST_SCALE_BITS.
const int iScaleBits[64] PROGMEM = {16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
    22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,
    21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,
    19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,
    16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
    12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,
    8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
    4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247};

// Pre-calculated Huffman encode tables (4K bytes)
const uint8_t hufftable[] PROGMEM = {
    0x00,0x00,0x02,0x00,0x03,0x00,0x04,0x00,0x05,0x00,0x06,0x00,0x0e,0x00,0x1e,0x00,
    0x3e,0x00,0x7e,0x00,0xfe,0x00,0xfe,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x02,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x04,0x00,0x05,0x00,
    0x06,0x00,0x07,0x00,0x08,0x00,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x0a,0x00,0x00,0x00,0x01,0x00,0x04,0x00,0x0b,0x00,0x1a,0x00,0x78,0x00,0xf8,0x00,
    0xf6,0x03,0x82,0xff,0x83,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x0c,0x00,0x1b,0x00,0x79,0x00,0xf6,0x01,0xf6,0x07,0x84,0xff,0x85,0xff,
    0x86,0xff,0x87,0xff,0x88,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x1c,0x00,0xf9,0x00,0xf7,0x03,0xf4,0x0f,0x89,0xff,0x8a,0xff,0x8b,0xff,
    0x8c,0xff,0x8d,0xff,0x8e,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x3a,0x00,0xf7,0x01,0xf5,0x0f,0x8f,0xff,0x90,0xff,0x91,0xff,0x92,0xff,
    0x93,0xff,0x94,0xff,0x95,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x3b,0x00,0xf8,0x03,0x96,0xff,0x97,0xff,0x98,0xff,0x99,0xff,0x9a,0xff,
    0x9b,0xff,0x9c,0xff,0x9d,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7a,0x00,0xf7,0x07,0x9e,0xff,0x9f,0xff,0xa0,0xff,0xa1,0xff,0xa2,0xff,
    0xa3,0xff,0xa4,0xff,0xa5,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7b,0x00,0xf6,0x0f,0xa6,0xff,0xa7,0xff,0xa8,0xff,0xa9,0xff,0xaa,0xff,
    0xab,0xff,0xac,0xff,0xad,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfa,0x00,0xf7,0x0f,0xae,0xff,0xaf,0xff,0xb0,0xff,0xb1,0xff,0xb2,0xff,
    0xb3,0xff,0xb4,0xff,0xb5,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xf8,0x01,0xc0,0x7f,0xb6,0xff,0xb7,0xff,0xb8,0xff,0xb9,0xff,0xba,0xff,
    0xbb,0xff,0xbc,0xff,0xbd,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xf9,0x01,0xbe,0xff,0xbf,0xff,0xc0,0xff,0xc1,0xff,0xc2,0xff,0xc3,0xff,
    0xc4,0xff,0xc5,0xff,0xc6,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfa,0x01,0xc7,0xff,0xc8,0xff,0xc9,0xff,0xca,0xff,0xcb,0xff,0xcc,0xff,
    0xcd,0xff,0xce,0xff,0xcf,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xf9,0x03,0xd0,0xff,0xd1,0xff,0xd2,0xff,0xd3,0xff,0xd4,0xff,0xd5,0xff,
    0xd6,0xff,0xd7,0xff,0xd8,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfa,0x03,0xd9,0xff,0xda,0xff,0xdb,0xff,0xdc,0xff,0xdd,0xff,0xde,0xff,
    0xdf,0xff,0xe0,0xff,0xe1,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xf8,0x07,0xe2,0xff,0xe3,0xff,0xe4,0xff,0xe5,0xff,0xe6,0xff,0xe7,0xff,
    0xe8,0xff,0xe9,0xff,0xea,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xeb,0xff,0xec,0xff,0xed,0xff,0xee,0xff,0xef,0xff,0xf0,0xff,0xf1,0xff,
    0xf2,0xff,0xf3,0xff,0xf4,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0xf9,0x07,0xf5,0xff,0xf6,0xff,0xf7,0xff,0xf8,0xff,0xf9,0xff,0xfa,0xff,0xfb,0xff,
    0xfc,0xff,0xfd,0xff,0xfe,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x04,0x00,0x02,0x00,0x02,0x00,0x03,0x00,0x04,0x00,0x05,0x00,0x07,0x00,0x08,0x00,
    0x0a,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x04,0x00,0x05,0x00,0x07,0x00,0x09,0x00,0x0b,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x05,0x00,0x08,0x00,0x0a,0x00,0x0c,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x06,0x00,0x09,0x00,0x0c,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x06,0x00,0x0a,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x07,0x00,0x0b,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x07,0x00,0x0c,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x08,0x00,0x0c,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x09,0x00,0x0f,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x09,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x09,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x0a,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x0a,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x0b,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x0b,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x01,0x00,0x02,0x00,0x06,0x00,0x0e,0x00,0x1e,0x00,0x3e,0x00,0x7e,0x00,
    0xfe,0x00,0xfe,0x01,0xfe,0x03,0xfe,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x02,0x00,0x02,0x00,0x02,0x00,0x03,0x00,0x04,0x00,0x05,0x00,0x06,0x00,0x07,0x00,
    0x08,0x00,0x09,0x00,0x0a,0x00,0x0b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x01,0x00,0x04,0x00,0x0a,0x00,0x18,0x00,0x19,0x00,0x38,0x00,0x78,0x00,
    0xf4,0x01,0xf6,0x03,0xf4,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x0b,0x00,0x39,0x00,0xf6,0x00,0xf5,0x01,0xf6,0x07,0xf5,0x0f,0x88,0xff,
    0x89,0xff,0x8a,0xff,0x8b,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x1a,0x00,0xf7,0x00,0xf7,0x03,0xf6,0x0f,0xc2,0x7f,0x8c,0xff,0x8d,0xff,
    0x8e,0xff,0x8f,0xff,0x90,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x1b,0x00,0xf8,0x00,0xf8,0x03,0xf7,0x0f,0x91,0xff,0x92,0xff,0x93,0xff,
    0x94,0xff,0x95,0xff,0x96,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x3a,0x00,0xf6,0x01,0x97,0xff,0x98,0xff,0x99,0xff,0x9a,0xff,0x9b,0xff,
    0x9c,0xff,0x9d,0xff,0x9e,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x3b,0x00,0xf9,0x03,0x9f,0xff,0xa0,0xff,0xa1,0xff,0xa2,0xff,0xa3,0xff,
    0xa4,0xff,0xa5,0xff,0xa6,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x79,0x00,0xf7,0x07,0xa7,0xff,0xa8,0xff,0xa9,0xff,0xaa,0xff,0xab,0xff,
    0xac,0xff,0xad,0xff,0xae,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7a,0x00,0xf8,0x07,0xaf,0xff,0xb0,0xff,0xb1,0xff,0xb2,0xff,0xb3,0xff,
    0xb4,0xff,0xb5,0xff,0xb6,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xf9,0x00,0xb7,0xff,0xb8,0xff,0xb9,0xff,0xba,0xff,0xbb,0xff,0xbc,0xff,
    0xbd,0xff,0xbe,0xff,0xbf,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xf7,0x01,0xc0,0xff,0xc1,0xff,0xc2,0xff,0xc3,0xff,0xc4,0xff,0xc5,0xff,
    0xc6,0xff,0xc7,0xff,0xc8,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xf8,0x01,0xc9,0xff,0xca,0xff,0xcb,0xff,0xcc,0xff,0xcd,0xff,0xce,0xff,
    0xcf,0xff,0xd0,0xff,0xd1,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xf9,0x01,0xd2,0xff,0xd3,0xff,0xd4,0xff,0xd5,0xff,0xd6,0xff,0xd7,0xff,
    0xd8,0xff,0xd9,0xff,0xda,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfa,0x01,0xdb,0xff,0xdc,0xff,0xdd,0xff,0xde,0xff,0xdf,0xff,0xe0,0xff,
    0xe1,0xff,0xe2,0xff,0xe3,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xf9,0x07,0xe4,0xff,0xe5,0xff,0xe6,0xff,0xe7,0xff,0xe8,0xff,0xe9,0xff,
    0xea,0xff,0xeb,0xff,0xec,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xe0,0x3f,0xed,0xff,0xee,0xff,0xef,0xff,0xf0,0xff,0xf1,0xff,0xf2,0xff,
    0xf3,0xff,0xf4,0xff,0xf5,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0xfa,0x03,0xc3,0x7f,0xf6,0xff,0xf7,0xff,0xf8,0xff,0xf9,0xff,0xfa,0xff,0xfb,0xff,
    0xfc,0xff,0xfd,0xff,0xfe,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x02,0x00,0x02,0x00,0x03,0x00,0x04,0x00,0x05,0x00,0x05,0x00,0x06,0x00,0x07,0x00,
    0x09,0x00,0x0a,0x00,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x04,0x00,0x06,0x00,0x08,0x00,0x09,0x00,0x0b,0x00,0x0c,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x05,0x00,0x08,0x00,0x0a,0x00,0x0c,0x00,0x0f,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x05,0x00,0x08,0x00,0x0a,0x00,0x0c,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x06,0x00,0x09,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x06,0x00,0x0a,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x07,0x00,0x0b,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x07,0x00,0x0b,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x08,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x09,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x09,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x09,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x09,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x0b,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x0e,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x0a,0x00,0x0f,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
    0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
void JPEGFixQuantE(JPEGE_IMAGE *pJPEG)
{
    int iTable, iTableOffset;
    signed short sTemp[DCTSIZE];
    int i, iCount;
    signed short *p;
    unsigned short *pus;
    
    if (pJPEG->ucNumComponents == 1)
        iCount = 1;
    else
        iCount = 2;
    
    for (iTable = 0; iTable < iCount; iTable++)
    {
        iTableOffset = iTable * DCTSIZE;
        p = (signed short *) &pJPEG->sQuantTable[iTableOffset];
        for (i = 0; i < DCTSIZE; i++)
        {
            sTemp[i] = p[cZigZag[i]];
        }
        memcpy(&pJPEG->sQuantTable[iTableOffset], sTemp, DCTSIZE*sizeof(short)); // copy back to original spot
        
        // Prescale for DCT multiplication
        p = (signed short *) &pJPEG->sQuantTable[iTableOffset];
        for (i = 0; i < DCTSIZE; i++)
        {
            p[i] = (short) ((p[i] * iScaleBits[i]) >> 11);
        }
        // Create "inverted" values for quicker multiplication instead of division
        pus = (unsigned short *) &pJPEG->sQuantTable[iTableOffset];
        for (i = 0; i < DCTSIZE; i++)
        {
            int j;
            if (pus[i] != 0)
                j = 65536 / pus[i];
            else
                j = 0;
            pus[i+(DCTSIZE*2)] = (unsigned short)j;
        }
    } // for iTable
} /* JPEGFixQuantE() */

void JPEGMakeHuffE(JPEGE_IMAGE *pJPEG)
{
#ifdef USE_RAM_FOR_TABLES
    int code, iLen, iTable;
    unsigned short *pTable;
    int iBitNum; // current code bit length
    int n_bits; // number of bits to do
    int cc; // code
    unsigned char *p, *pBits;
    int iTableCount;

    if (pJPEG->ucNumComponents == 1)
        iTableCount = 1;
    else
        iTableCount = 2;

    // first do DC components (up to 12-bit codes)
    for (iTable = 0; iTable < iTableCount; iTable++)
    {
        pJPEG->huffdc[iTable] = (int *)&pJPEG->ucHuffACDCBuf[iTable*0x800]; // each table gets 2K
        pTable = (unsigned short *)pJPEG->huffdc[iTable];
        if (iTable == 0)
            pBits = (unsigned char *)huffl_dc;
        else
            pBits = (unsigned char *)huffcr_dc;
        p = (unsigned char *)pBits;
        p += 16; // point to bit data
        iBitNum = 1;
        cc = 0; // start with a code of 0
        for (n_bits = 0; n_bits < 16; n_bits++)
        {
            iLen = *pBits++; // get number of codes for this bit length
            while (iLen)
            {
                code = *p++;  // get actual huffman code
                pTable[code] = (unsigned short)cc;
                pTable[code+256] = (unsigned short)iBitNum; // store the length here
                cc++;
                iLen--;
            }
            iBitNum++;
            cc <<= 1;
        }
    }
    // now do AC components (up to 16-bit codes)
    for (iTable = 0; iTable < iTableCount; iTable++)
    {
        pTable = (unsigned short *)pJPEG->huffdc[iTable];
        if (iTable == 0)
            pBits = (unsigned char *)huffl_ac;
        else
            pBits = (unsigned char *)huffcr_ac;
        p = (unsigned char *)pBits;
        p += 16; // point to bit data
        iBitNum = 1;
        cc = 0; // start with a code of 0
        for (n_bits = 0; n_bits < 16; n_bits++)
        {
            iLen = *pBits++; // get number of codes for this bit length
            while (iLen)
            {
                code = *p++;  // get actual huffman code
                pTable[512+code] = (unsigned short)cc;
                pTable[768+code] = (unsigned short)iBitNum;
                cc++;
                iLen--;
            }
            iBitNum++;
            cc <<= 1;
        }
    }
    // write it to a file
//    {
//        FILE *ohandle = fopen("/Users/laurencebank/Downloads/hufftable.bin", "w+b");
//        if (ohandle) {
//            fwrite(pJPEG->ucHuffACDCBuf, 1, 4096, ohandle);
//            fclose(ohandle);
//        }
//    }
#else // read it from FLASH
    pJPEG->huffdc[0] = (int *)&hufftable[0];
    pJPEG->huffdc[1] = (int *)&hufftable[2048];
#endif // USE_RAM_FOR_TABLES
} /* JPEGMakeHuffE() */
//
// Finish the file
//
int JPEGEncodeEnd(JPEGE_IMAGE *pJPEG)
{
    if (pJPEG->iError == JPEGE_SUCCESS)
    {
        if (pJPEG->pOutput == NULL) { // file I/O
            int iLen;
            *pJPEG->pc.pOut++ = 0xff; // end of image (EOI)
            *pJPEG->pc.pOut++ = 0xd9;
            iLen = (int)(pJPEG->pc.pOut - pJPEG->ucFileBuf);
            pJPEG->pfnWrite(&pJPEG->JPEGFile, pJPEG->ucFileBuf, iLen);
            pJPEG->iDataSize += iLen;
        } else { // user-supplied buffer
            uint8_t *pBuf = pJPEG->pOutput; // DEBUG - check for non-buffer option
            int iOutSize = pJPEG->iDataSize;
            pBuf[iOutSize++] = 0xff;
            pBuf[iOutSize++] = 0xd9;  // end of image (EOI)
            pJPEG->iDataSize = iOutSize;
        }
        return pJPEG->iDataSize; // return the size of the compressed data
    }
    return 0; // something went wrong
} /* JPEGEncodeEnd() */
//
// Initialize the encoder
//
int JPEGEncodeBegin(JPEGE_IMAGE *pJPEG, JPEGENCODE *pEncode, int iWidth, int iHeight, uint8_t ucPixelType, uint8_t ucSubSample, uint8_t ucQFactor)
{
    uint8_t *pBuf;
    int i;
    int iOffset = 0;
    if (pEncode == NULL || pJPEG == NULL) {
        return JPEGE_INVALID_PARAMETER;
    }
    if (iWidth < 1 || iHeight < 1) {
        return JPEGE_INVALID_PARAMETER;
    }
    if (ucPixelType >= JPEGE_PIXEL_COUNT || (ucSubSample != JPEGE_SUBSAMPLE_444 && ucSubSample != JPEGE_SUBSAMPLE_420) || ucQFactor > JPEGE_Q_LOW) {
        return JPEGE_INVALID_PARAMETER;
    }
    pJPEG->iDCPred0 = pJPEG->iDCPred1 = pJPEG->iDCPred2 = 0; // DC predictor values reset to 0
    pJPEG->iWidth = iWidth;
    pJPEG->iHeight = iHeight;
    pJPEG->ucPixelType = ucPixelType;
    pJPEG->ucSubSample = ucSubSample;
    pEncode->x = pEncode->y = 0; // starting point
    if (ucSubSample == JPEGE_SUBSAMPLE_444) {
        pEncode->cx = pEncode->cy = 8;
    } else {
        pEncode->cx = pEncode->cy = 16; // MCU size
    }
    // Number of MCUs in each dimension
    pJPEG->iMCUWidth = (pJPEG->iWidth + pEncode->cx - 1) / pEncode->cx;
    pJPEG->iMCUHeight = (pJPEG->iHeight + pEncode->cy - 1) / pEncode->cy;
    
    // Set up the output buffer
    pJPEG->pc.iLen = pJPEG->pc.ulAcc = 0;
    if (pJPEG->pOutput) {
        pBuf = pJPEG->pOutput;
    } else {
        pBuf = pJPEG->ucFileBuf;
    }
    // Write the JPEG header
    if (pJPEG->ucPixelType == JPEGE_PIXEL_GRAYSCALE)
        pJPEG->ucNumComponents = 1;
    else
        pJPEG->ucNumComponents = 3;
    WRITEMOTO32(pBuf, iOffset, 0xffd8ffe0); // write app0 marker
    iOffset += 4;
    WRITEMOTO32(pBuf, iOffset, 0x00104a46); // JFIF
    iOffset += 4;
    WRITEMOTO32(pBuf, iOffset, 0x49460001);
    iOffset += 4;
    WRITEMOTO16(pBuf, iOffset, 0x0101); // resolution units = dots per inch
    iOffset += 2;
    WRITEMOTO16(pBuf, iOffset, 0); // DEBUG - store spacial resolution as 0 for now
    iOffset += 2;
    WRITEMOTO16(pBuf, iOffset, 0);
    iOffset += 2;
    WRITEMOTO16(pBuf, iOffset, 0); // add 2 zeros
    iOffset += 2;
    // define quantization tables
    WRITEMOTO16(pBuf, iOffset, 0xffdb); // quantization table marker
    iOffset += 2;
    WRITEMOTO16(pBuf, iOffset, 0x0043); // table size
    iOffset += 2;
    pBuf[iOffset++] = 0; // table type and number 0,8 bit
    for (i=0; i<64; i++)
    {
        switch (ucQFactor) // adjust table depending on quality factor
        {
            default:
            case JPEGE_Q_BEST: // best quality, divide by 4
                pBuf[iOffset++] = quant_lum[i] >> 2;
                break;
            case JPEGE_Q_HIGH: // high quality, divide by 2
                pBuf[iOffset++] = quant_lum[i] >> 1;
                break;
            case JPEGE_Q_MED: // medium quality factor, use values unchanged
                pBuf[iOffset++] = quant_lum[i];
                break;
            case JPEGE_Q_LOW: // low quality, use values * 2
                pBuf[iOffset++] = quant_lum[i] << 1;
                break;
//            case 4: // ridiculously high quality
//                pBuf[iOffset++] = quant95_lum[i];
//                break;
        }
    }
    if (pJPEG->ucPixelType != JPEGE_PIXEL_GRAYSCALE) // add color quant tables
    {
        WRITEMOTO16(pBuf, iOffset, 0xffdb); // quantization table
        iOffset += 2;
        WRITEMOTO16(pBuf, iOffset, 0x0043); // table size
        iOffset += 2;
        pBuf[iOffset++] = 1;  // table 1, 8 bit
        for (i=0; i<64; i++)
        {
            switch (ucQFactor) // adjust table depending on quality factor
            {
                case JPEGE_Q_BEST: // best quality, divide by 4
                    pBuf[iOffset++] = quant_color[i] >> 2;
                    break;
                case JPEGE_Q_HIGH: // high quality, divide by 2
                    pBuf[iOffset++] = quant_color[i] >> 1;
                    break;
                case JPEGE_Q_MED: // medium quality factor, use values unchanged
                    pBuf[iOffset++] = quant_color[i];
                    break;
                case JPEGE_Q_LOW: // low quality, use values * 2
                    pBuf[iOffset++] = quant_color[i] << 1;
                    break;
//                case 4: // ridiculously high quality
//                    pBuf[iOffset++] = quant95_color[i];
//                    break;
            }
        }
    }
    // store the restart interval
    // use an interval of one MCU row
    if (pJPEG->ucPixelType != JPEGE_PIXEL_GRAYSCALE && pJPEG->ucSubSample == JPEGE_SUBSAMPLE_420)
        i = (pJPEG->iWidth + 15) / 16; // number of MCUs in a row
    else
        i = (pJPEG->iWidth + 7) / 8;
    WRITEMOTO16(pBuf, iOffset, 0xffdd); // DRI marker
    iOffset += 2;
    WRITEMOTO16(pBuf, iOffset, 4); // fixed length of 4
    iOffset += 2;
    WRITEMOTO16(pBuf, iOffset, i); // restart interval count
    iOffset += 2;
    
    // store the frame header
    WRITEMOTO16(pBuf, iOffset, 0xffc0); // SOF0 marker
    iOffset += 2;
    if (pJPEG->ucPixelType == JPEGE_PIXEL_GRAYSCALE)
    {
        pBuf[iOffset++] = 0;
        pBuf[iOffset++] = 11; // length = 11
        pBuf[iOffset++] = 8;   // sample precision
        WRITEMOTO16(pBuf, iOffset, pJPEG->iHeight); // image height
        iOffset += 2;
        WRITEMOTO16(pBuf, iOffset, pJPEG->iWidth); // image width
        iOffset += 2;
        pBuf[iOffset++] = 1; // number of components = 1 (grayscale)
        pBuf[iOffset++] = 0; // component number
        WRITEMOTO16(pBuf, iOffset, 0x1100); // subsampling and quant table selector
        iOffset += 2;
    }
    else  // set up color stuff
    {
        pBuf[iOffset++] = 0;
        pBuf[iOffset++] = 17; // length = 17
        pBuf[iOffset++] = 8;   // sample precision
        WRITEMOTO16(pBuf, iOffset, pJPEG->iHeight); // image height
        iOffset += 2;
        WRITEMOTO16(pBuf, iOffset, pJPEG->iWidth); // image width
        iOffset += 2;
        pBuf[iOffset++] = 3; // number of components = 3 (Ycc)
        pBuf[iOffset++] = 0; // component number 0 (Y)
        if (pJPEG->ucSubSample == JPEGE_SUBSAMPLE_420)
        {
            WRITEMOTO16(pBuf, iOffset, 0x2200); // 2:1 subsampling and quant table selector
        }
        else
        {
            WRITEMOTO16(pBuf, iOffset, 0x1100); // no subsampling and quant table selector
        }
        iOffset += 2;
        pBuf[iOffset++] = 1; // component number 1 (Cb)
        WRITEMOTO16(pBuf, iOffset, 0x1101); // subsampling and quant table selector
        iOffset += 2;
        pBuf[iOffset++] = 2; // component number 2 (Cr)
        WRITEMOTO16(pBuf, iOffset, 0x1101); // subsampling and quant table selector
        iOffset += 2;
    }
    // define Huffman tables
    WRITEMOTO16(pBuf, iOffset, 0xffc4); // Huffman DC table
    iOffset += 2;
    WRITEMOTO16(pBuf, iOffset, 0x1f); // Table length = 31
    iOffset += 2;
    pBuf[iOffset++] = 0; // table class = 0 (DC), id = 0
    memcpy(&pBuf[iOffset], huffl_dc, 28); // copy DC table
    iOffset += 28;
    // now the AC table
    WRITEMOTO16(pBuf, iOffset, 0xffc4); // Huffman AC table
    iOffset += 2;
    WRITEMOTO16(pBuf, iOffset, 0xb5); // Table length = 181
    iOffset += 2;
    pBuf[iOffset++] = 0x10; // table class = 1 (AC), id = 0
    memcpy(&pBuf[iOffset], huffl_ac, 178); // copy AC table
    iOffset += 178;
    if (pJPEG->ucPixelType != JPEGE_PIXEL_GRAYSCALE) // define a second set of tables for color
    {
        WRITEMOTO16(pBuf, iOffset, 0xffc4); // Huffman DC table
        iOffset += 2;
        WRITEMOTO16(pBuf, iOffset, 0x1f); // Table length = 31
        iOffset += 2;
        pBuf[iOffset++] = 1; // table class = 0 (DC), id = 1
        memcpy(&pBuf[iOffset], huffcr_dc, 28); // copy DC table
        iOffset += 28;
        // now the AC table
        WRITEMOTO16(pBuf, iOffset, 0xffc4); // Huffman AC table
        iOffset += 2;
        WRITEMOTO16(pBuf, iOffset, 0xb5); // Table length = 181
        iOffset += 2;
        pBuf[iOffset++] = 0x11; // table class = 1 (AC), id = 1
        memcpy(&pBuf[iOffset], huffcr_ac, 178); // copy AC table
        iOffset += 178;
    }
    // Define the start of scan header (SOS)
    WRITEMOTO16(pBuf, iOffset, 0xffda); // SOS
    iOffset += 2;
    if (pJPEG->ucPixelType == JPEGE_PIXEL_GRAYSCALE)
    {
        WRITEMOTO16(pBuf, iOffset, 0x8); // Table length = 8
        iOffset += 2;
        pBuf[iOffset++] = 1;            // number of components in scan = 1 (grayscale)
        pBuf[iOffset++] = 0; // component id = 0
        pBuf[iOffset++] = 0; // dc/ac huffman table = 0/0
    }
    else // color
    {
        WRITEMOTO16(pBuf, iOffset, 0xc); // Table length = 12
        iOffset += 2;
        pBuf[iOffset++] = 3;            // number of components in scan = 3 (color)
        pBuf[iOffset++] = 0; // component id = 0
        pBuf[iOffset++] = 0; // dc/ac huffman table = 0/0
        pBuf[iOffset++] = 1; // component id = 1
        pBuf[iOffset++] = 0x11; // dc/ac huffman table = 1/1
        pBuf[iOffset++] = 2; // component id = 2
        pBuf[iOffset++] = 0x11; // dc/ac huffman table = 1/1
    }
    pBuf[iOffset++] = 0; // start of spectral selection
    pBuf[iOffset++] = 63; // end of spectral selection
    pBuf[iOffset++] = 0; // successive approximation bit
    // Set the output pointer for writing the variable length codes
    pJPEG->pc.pOut = &pBuf[iOffset];
    
    // prepare the luma & chroma quantization tables
    for (i = 0; i<64; i++)
    {
        switch (ucQFactor)
        {
            case JPEGE_Q_BEST:
                pJPEG->sQuantTable[i] = quant_lum[i] >> 2;
                pJPEG->sQuantTable[i + 64] = quant_color[i] >> 2;
                break;
            case JPEGE_Q_HIGH:
                pJPEG->sQuantTable[i] = (quant_lum[i] >> 1);
                pJPEG->sQuantTable[i + 64] = (quant_color[i] >> 1);
                break;
            case JPEGE_Q_MED:
                pJPEG->sQuantTable[i] = quant_lum[i];
                pJPEG->sQuantTable[i + 64] = quant_color[i];
                break;
            case JPEGE_Q_LOW:
                pJPEG->sQuantTable[i] = (quant_lum[i] << 1);
                pJPEG->sQuantTable[i + 64] = (quant_color[i] << 1);
                break;
//            case 4: // ridiculous quality
//                pJPEG->sQuantTable[i] = quant95_lum[i];
//                pJPEG->sQuantTable[i + 64] = quant95_color[i];
//                break;
        }
    }
    JPEGFixQuantE(pJPEG); // reorder and scale quant table(s)
    JPEGMakeHuffE(pJPEG); // create the Huffman tables to encode
    pJPEG->iError = JPEGE_SUCCESS;
    return JPEGE_SUCCESS;
} /* JPEGEncodeBegin() */

int JPEGQuantize(JPEGE_IMAGE *pJPEG, signed short *pMCUSrc, int iTable)
{
    signed int d, sQ1, sQ2, sum;
    int i;
    signed short *pQuant;
    
    pQuant = (signed short *)&pJPEG->sQuantTable[iTable * DCTSIZE];
    for (i=0; i<33; i++) // do first half and then check for second half being all 0's
    {
        sQ1 = pQuant[i];
        sQ2 = sQ1 >> 1;
        d = *pMCUSrc;
        // Avoid doing divides; the second half of the quantization table has 65536/Q values
        // so that we can use multiplies in this step
        if (d < 0)
        {
            *pMCUSrc++ = 0 - (((sQ2 - d) * pQuant[i + 128]) >> 16);
        }
        else
        {
            *pMCUSrc++ = (((sQ2 + d) * pQuant[i + 128]) >> 16);
        }
    } // for
    sum = 0;
    for (i=33; i<64; i++) // second half; check for 'sparseness'
    {
        sQ1 = pQuant[i];
        sQ2 = sQ1 >> 1;
        d = *pMCUSrc;
        // Avoid doing divides; the second half of the quantization table has 65536/Q values
        // so that we can use multiplies in this step
        if (d < 0)
        {
            d = 0 - (((sQ2 - d) * pQuant[i + 128]) >> 16);
            sum -= d;
        }
        else
        {
            d = (((sQ2 + d) * pQuant[i + 128]) >> 16);
            sum += d;
        }
        *pMCUSrc++ = d;
    } // for
    return (sum == 0); // if the last half of the quantized results was 0, call it 'sparse'
} /* JPEGQuantize() */

int JPEGEncodeMCU(int iDCTable, JPEGE_IMAGE *pJPEG, signed short *pMCUData, int iDCPred, int bSparse)
{
    //int iOff, iBitnum; // faster access
    unsigned char cMagnitude;
    unsigned char ucCode, *pZig, *pZigEnd, *pZigStart;
    int iZeroCount;
    BIGINT iDelta;
    BIGUINT iLen, iNewLen;
    unsigned short *pHuff;
    BIGUINT ulCode;
    unsigned char *pOut;
    BIGUINT ulAcc;
    uint32_t ulMagVal;
    uint32_t *pMagFix = (uint32_t *)&ulMagnitudeFix[1024]; // allows indexing positive and negative values - speeds up total encode time by 15%
    
    // Put in local vars to allow compiler to do a better job of optimization using registers
    ulAcc = pJPEG->pc.ulAcc;
    pOut = pJPEG->pc.pOut;
    iLen = pJPEG->pc.iLen;
    
    // compress the DC component
    iDelta = pMCUData[0] - iDCPred;
    iDCPred = pMCUData[0]; // this is the new DC value
    pHuff = (unsigned short *) pJPEG->huffdc[iDCTable];
    ulMagVal = pMagFix[iDelta]; // get magnitude and new delta in one table read
    iDelta = (ulMagVal >> 16);
    cMagnitude = ulMagVal & 0xf;
    // Old way of dealing with negative and positive magnitudes; faster to use a lookup table once
    //   if (iDelta < 0)
    //      {
    //      iDelta = 0 - iDelta;
    //      cMagnitude = cMagnitudes[iDelta];
    //      iDelta = iBitMasks[cMagnitude] - iDelta;
    //      }
    //   else
    //      {
    //      cMagnitude = cMagnitudes[iDelta];
    //      }
    ulCode = (BIGUINT) pHuff[cMagnitude];
    iNewLen = pHuff[cMagnitude + 256];
    ulCode = (ulCode << cMagnitude) | iDelta; // code in msb, followed by delta
    iNewLen += cMagnitude; // add lengths together
    STORECODE(pOut, iLen, ulCode, ulAcc, iNewLen)
    // Encode the AC components
    pZig = (unsigned char *)&cZigZag2[1];
    if (bSparse)
        pZigEnd = (unsigned char *)&cZigZag2[33]; // second half is all zeros
    else
        pZigEnd = (unsigned char *)&cZigZag2[64];
    pHuff += 512; // point to AC table
    while (pZig < pZigEnd)
    {
        // count the number of leading zeros
        pZigStart = pZig;
        while (pZig < pZigEnd && (iDelta = pMCUData[pZig[0]]) == 0) {
            pZig++;
        }
        if (pZig == pZigEnd) // special case, no more coefficients
        { // encode EOB (end of block)
            ulCode = (BIGUINT) pHuff[0];
            iNewLen = pHuff[256];
            STORECODE(pOut, iLen, ulCode, ulAcc, iNewLen)
            goto encodemcuz;
        }
        else // Encode a zero count and AC coefficient
        {
            iZeroCount = (int)(pZig - pZigStart);
            while (iZeroCount >= 16)  // maximum that can be encoded at once
            { // 16 zeros is called ZRL (f0)
                ulCode = (uint32_t)pHuff[0xf0];
                iNewLen = pHuff[256 + 0xf0];
                STORECODE(pOut, iLen, ulCode, ulAcc, iNewLen)
                iZeroCount -= 16;
            }
            // Encode a normal RRRR/SSSS pair
            ulMagVal = pMagFix[iDelta]; // get magnitude and new delta in one table read
            iDelta = (ulMagVal >> 16);
            cMagnitude = ulMagVal & 0xf;
            ucCode = (unsigned char)((iZeroCount << 4) | cMagnitude); // combine zero count and 'extra' size
            // store the huffman code
            ulCode = (uint32_t)pHuff[ucCode];
            iNewLen = pHuff[256 + ucCode];
            ulCode = (ulCode << cMagnitude) | iDelta; // code followed by magnitude
            pZig++;  // skip to next coefficient
            iNewLen += cMagnitude;
            STORECODE(pOut, iLen, ulCode, ulAcc, iNewLen)
        }
    }
    
encodemcuz:
    pJPEG->pc.ulAcc = ulAcc; // place local copies back in the object pointer version
    pJPEG->pc.pOut = pOut;
    pJPEG->pc.iLen = iLen;
    return iDCPred;
    
} /* JPEGEncodeMCU() */

void JPEGGetMCU(unsigned char *pSrc, int iPitch, signed char *pMCU)
{
    int cy;
    
    for (cy = 0; cy < 8; cy++) {
        *(uint32_t *)pMCU = *(uint32_t *)pSrc ^ 0x80808080;
        *(uint32_t *)&pMCU[4] = *(uint32_t *)&pSrc[4] ^ 0x80808080;
        pMCU += 8;
        pSrc += iPitch; // - 8; // skip to next line
    }
} /* JPEGGetMCU() */

void JPEGSubSample24(unsigned char *pSrc, signed char *pLUM, signed char *pCb, signed char *pCr, int lsize, int cx, int cy, uint8_t ucPixelTyp)
{
    int x;
    unsigned char cRed, cGreen, cBlue;
    int iY1, iY2, iY3, iY4, iCr1, iCr2, iCr3, iCr4, iCb1, iCb2, iCb3, iCb4;
    int y;
    int redOffset, greenOffset, blueOffset;
    
    cx = (cx + 1)>>1; // do pixels in 2x2 blocks
    cy = (cy + 1)>>1;

    if (ucPixelTyp == JPEGE_PIXEL_RGB888)
    {
        redOffset = 0;
        greenOffset = 1;
        blueOffset = 2;
    }
    else
    {
        redOffset = 2;
        greenOffset = 1;
        blueOffset = 0;
    }

    for (y=0; y<cy; y++)
    {
        for (x = 0; x<cx; x++) // do 8x8 pixels in 2x2 blocks
        {
            cBlue = pSrc[blueOffset];
            cGreen = pSrc[greenOffset];
            cRed = pSrc[redOffset];
            iY1 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb1 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr1 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            cBlue = pSrc[blueOffset + 3];
            cGreen = pSrc[greenOffset + 3];
            cRed = pSrc[redOffset + 3];
            iY2 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb2 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr2 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            cBlue = pSrc[blueOffset + lsize];
            cGreen = pSrc[greenOffset + lsize];
            cRed = pSrc[redOffset + lsize];
            iY3 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb3 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr3 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            cBlue = pSrc[blueOffset + lsize + 3];
            cGreen = pSrc[greenOffset + lsize + 3];
            cRed = pSrc[redOffset + lsize + 3];
            iY4 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb4 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr4 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            // Average the chroma values together
            iCr1 = (iCr1 + iCr2 + iCr3 + iCr4) >> 14;
            iCb1 = (iCb1 + iCb2 + iCb3 + iCb4) >> 14;
            
            // store in the MCUs
            pLUM[0] = (signed char)iY1;
            pLUM[1] = (signed char)iY2;
            pLUM[8] = (signed char)iY3;
            pLUM[9] = (signed char)iY4;
            pLUM += 2;
            pCr[0] = (signed char)iCr1;
            pCb[0] = (signed char)iCb1;
            pCr++;
            pCb++;
            pSrc += 6; // skip 2 pixels to right
        } // for x
        pCr += 8 - cx; // skip to next row;
        pCb += 8 - cx;
        pLUM += 8 + (4-cx)*2; // skip down a row since 2 at a time
        pSrc += lsize*2 - cx*6; // skip 2 lines
    } // for y
    
} /* JPEGSubSample24() */
void JPEGSubSample16(unsigned char *pSrc, signed char *pLUM, signed char *pCb, signed char *pCr, int lsize, int cx, int cy, uint8_t ucPixelTyp)
{
    int x, y;
    unsigned short us;
    unsigned short *pUS = (unsigned short *)pSrc;
    unsigned char cRed, cGreen, cBlue;
    int iY1, iY2, iY3, iY4, iCr1, iCr2, iCr3, iCr4, iCb1, iCb2, iCb3, iCb4;
    
    cx = (cx + 1)>>1; // do pixels in 2x2 blocks
    cy = (cy + 1)>>1;
    
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++) // do 8x8 pixels in 2x2 blocks
        {
            us = pUS[0];
            if (ucPixelTyp == JPEGE_PIXEL_RGB565)
            {
                cBlue = (unsigned char)(((us & 0x1f)<<3) | (us & 7));
                cGreen = (unsigned char)(((us & 0x7e0)>>3) | ((us & 0x60)>>5));
                cRed = (unsigned char)(((us & 0xf800)>>8) | ((us & 0x3800)>>11));
            }
            else
            {
                cBlue = (unsigned char)(((us & 0xf800)>>8) | ((us & 0x3800)>>11));
                cGreen = (unsigned char)(((us & 0x7e0)>>3) | ((us & 0x60)>>5));
                cRed = (unsigned char)(((us & 0x1f)<<3) | (us & 7));
            }
            iY1 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb1 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr1 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            us = pUS[1];
            if (ucPixelTyp == JPEGE_PIXEL_RGB565)
            {
                cBlue = (unsigned char)(((us & 0x1f)<<3) | (us & 7));
                cGreen = (unsigned char)(((us & 0x7e0)>>3) | ((us & 0x60)>>5));
                cRed = (unsigned char)(((us & 0xf800)>>8) | ((us & 0x3800)>>11));
            }
            else
            {
                cBlue = (unsigned char)(((us & 0xf800)>>8) | ((us & 0x3800)>>11));
                cGreen = (unsigned char)(((us & 0x7e0)>>3) | ((us & 0x60)>>5));
                cRed = (unsigned char)(((us & 0x1f)<<3) | (us & 7));
            }
            iY2 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb2 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr2 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            us = pUS[lsize>>1];
            if (ucPixelTyp == JPEGE_PIXEL_RGB565)
            {
                cBlue = (unsigned char)(((us & 0x1f)<<3) | (us & 7));
                cGreen = (unsigned char)(((us & 0x7e0)>>3) | ((us & 0x60)>>5));
                cRed = (unsigned char)(((us & 0xf800)>>8) | ((us & 0x3800)>>11));
            }
            else
            {
                cBlue = (unsigned char)(((us & 0xf800)>>8) | ((us & 0x3800)>>11));
                cGreen = (unsigned char)(((us & 0x7e0)>>3) | ((us & 0x60)>>5));
                cRed = (unsigned char)(((us & 0x1f)<<3) | (us & 7));
            }
            iY3 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb3 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr3 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            us = pUS[(lsize>>1)+1];
            if (ucPixelTyp == JPEGE_PIXEL_RGB565)
            {
                cBlue = (unsigned char)(((us & 0x1f)<<3) | (us & 7));
                cGreen = (unsigned char)(((us & 0x7e0)>>3) | ((us & 0x60)>>5));
                cRed = (unsigned char)(((us & 0xf800)>>8) | ((us & 0x3800)>>11));
            }
            else
            {
                cBlue = (unsigned char)(((us & 0xf800)>>8) | ((us & 0x3800)>>11));
                cGreen = (unsigned char)(((us & 0x7e0)>>3) | ((us & 0x60)>>5));
                cRed = (unsigned char)(((us & 0x1f)<<3) | (us & 7));
            }
            iY4 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb4 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr4 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            // Average the chroma values together
            iCr1 = (iCr1 + iCr2 + iCr3 + iCr4) >> 14;
            iCb1 = (iCb1 + iCb2 + iCb3 + iCb4) >> 14;
            
            // store in the MCUs
            pLUM[0] = (signed char)iY1;
            pLUM[1] = (signed char)iY2;
            pLUM[8] = (signed char)iY3;
            pLUM[9] = (signed char)iY4;
            pLUM += 2;
            pCr[0] = (signed char)iCr1;
            pCb[0] = (signed char)iCb1;
            pCr++;
            pCb++;
            pUS += 2; // skip 2 pixels to right
        } // for x
        pCr += 8 - cx; // skip to next row;
        pCb += 8 - cx;
        pLUM += 8 + (4-cx)*2; // skip down a row since 2 at a time
        pUS += lsize - cx*2; // skip 2 lines
    } // for y
    
} /* JPEGSubSample16() */

void JPEGSubSample32(unsigned char *pSrc, signed char *pLUM, signed char *pCb, signed char *pCr, int lsize, int cx, int cy, uint8_t ucPixelType)
{
    int x;
    unsigned char cRed, cGreen, cBlue;
    int iY1, iY2, iY3, iY4, iCr1, iCr2, iCr3, iCr4, iCb1, iCb2, iCb3, iCb4;
    int y;
    int redOffset, greenOffset, blueOffset;

    cx = (cx + 1)>>1; // do pixels in 2x2 blocks
    cy = (cy + 1)>>1;

    if (ucPixelType == JPEGE_PIXEL_ARGB8888)
    {
        redOffset = 1;
        greenOffset = 2;
        blueOffset = 3;
    }
    else if  (ucPixelType == JPEGE_PIXEL_ABGR8888)
    {
        redOffset = 3;
        greenOffset = 2;
        blueOffset = 1;
    }
    else if (ucPixelType == JPEGE_PIXEL_RGBA8888)
    {
        redOffset = 0;
        greenOffset = 1;
        blueOffset = 2;
    }
    else
    {
        redOffset = 2;
        greenOffset = 1;
        blueOffset = 0;
    }

    for (y = 0; y<cy; y++)
    {
        for (x=0; x<cx; x++) // do 8x8 pixels in 2x2 blocks
        {
            cRed = pSrc[redOffset];
            cGreen = pSrc[greenOffset];
            cBlue = pSrc[blueOffset];
            iY1 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb1 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr1 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);

            cRed = pSrc[redOffset + 4];
            cGreen = pSrc[greenOffset + 4];
            cBlue = pSrc[blueOffset + 4];
            iY2 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb2 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr2 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);

            cRed = pSrc[redOffset + lsize];
            cGreen = pSrc[greenOffset + lsize];
            cBlue = pSrc[blueOffset + lsize];
            iY3 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb3 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr3 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);

            cRed = pSrc[redOffset + lsize + 4];
            cGreen = pSrc[greenOffset + lsize + 4];
            cBlue = pSrc[blueOffset + lsize + 4];
            iY4 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb4 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr4 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);

            // Average the chroma values together
            iCr1 = (iCr1 + iCr2 + iCr3 + iCr4) >> 14;
            iCb1 = (iCb1 + iCb2 + iCb3 + iCb4) >> 14;

            // store in the MCUs
            pLUM[0] = (signed char)iY1;
            pLUM[1] = (signed char)iY2;
            pLUM[8] = (signed char)iY3;
            pLUM[9] = (signed char)iY4;
            pLUM += 2;
            pCr[0] = (signed char)iCr1;
            pCb[0] = (signed char)iCb1;
            pCr++;
            pCb++;
            pSrc += 8; // skip 2 pixels to right
        } // for x
        pCr += 8 - cx; // skip to next row;
        pCb += 8 - cx;
        pLUM += 8 + (4-cx)*2; // skip down a row since 2 at a time
        pSrc += lsize*2 - cx*8; // skip 2 lines
    } // for y

} /* JPEGSubSample32() */

void JPEGSample32(unsigned char *pSrc, signed char *pMCU, int lsize, int cx, int cy, uint8_t ucPixelType)
{
    int x, y;
    unsigned char cRed, cGreen, cBlue;
    int iY, iCr, iCb;
   
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++) // do 8x8 pixels
        {
            if (ucPixelType == JPEGE_PIXEL_ARGB8888)
            {
                cRed = pSrc[1];
                cGreen = pSrc[2];
                cBlue = pSrc[3];
            }
            else if  (ucPixelType == JPEGE_PIXEL_ABGR8888)
            {
                cRed = pSrc[3];
                cGreen = pSrc[2];
                cBlue = pSrc[1];
            }
            else if (ucPixelType == JPEGE_PIXEL_RGBA8888)
            {
                cRed = pSrc[0];
                cGreen = pSrc[1];
                cBlue = pSrc[2];
            }
            else
            {
                cRed = pSrc[2];
                cGreen = pSrc[1];
                cBlue = pSrc[0];
            }
            pSrc += 4;
            iY = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);

            // store in the MCUs
            pMCU[64]  = (signed char)(iCb >> 12);
            pMCU[128]  = (signed char)(iCr >> 12);
            *pMCU++ = (signed char)iY;
        } // for x
        pMCU += 8 - cx;
        pSrc += lsize - cx*4;
    } // for y

} /* JPEGSample32() */

//
// U0 Y0 V0 Y1 U2 Y2 V2 Y3...
// The bytes coming from the GC0308 are reversed, 0=Y0, 1=U0, 2=Y1, etc
// assumes that the YUV422 will be converted to 4:2:0 subsampling
// YUV422 is horizontally subsampled; this code takes the average of each
// vertical pair of Cb/Cr and creates 4:2:0 from it
//
void JPEGSubSampleYUV422(uint8_t *pImage, int8_t *pMCUData, int iPitch)
{
int x, y;
uint8_t *pY0, *pY1, *pY2, *pY3;
uint8_t *pCr, *pCb;
uint8_t *s = pImage;
int iCr, iCb;
uint32_t *pU32;

  // output bins for YCbCr 
    pY0 = (uint8_t *)pMCUData; pY1 = (uint8_t *)&pMCUData[64*1];
    pY2 = (uint8_t *)&pMCUData[64*2]; pY3 = (uint8_t *)&pMCUData[64*3];
    pCr = (uint8_t *)&pMCUData[64*4]; pCb = (uint8_t *)&pMCUData[64*5];

  // subsample the UV vertically to get 4:2:0 from 4:2:2
    for (y=0; y<4; y ++) { // do 4 quadrants of 2x2 blocks of pixels at a time
        for (x=0; x<4; x++) {
            pY0[0] = s[0]; pY0[1] = s[2]; // top left
            pY0[8] = s[iPitch]; pY0[9] = s[iPitch+2];

            pY1[0] = s[16]; pY1[1] = s[18]; // top right
            pY1[8] = s[iPitch+16]; pY1[9] = s[iPitch+18];

            pY2[0] = s[(iPitch*8)+0]; pY2[1] = s[(iPitch*8)+2]; // bottom left
            pY2[8] = s[(iPitch*9)+0]; pY2[9] = s[(iPitch*9)+2];

            pY3[0] = s[(iPitch*8)+16]; pY3[1] = s[(iPitch*8)+18]; // bottom right
            pY3[8] = s[(iPitch*9)+16]; pY3[9] = s[(iPitch*9)+18];

            iCr = (s[1] + s[iPitch+1] + 1)/2; // subsample vertically
            iCb = (s[3] + s[iPitch+3] + 1)/2;
            pCr[0] = (int8_t)(iCr);
            pCb[0] = (int8_t)(iCb);
            iCr = (s[17] + s[iPitch+17] + 1)/2; // subsample vertically
            iCb = (s[19] + s[iPitch+19] + 1)/2;
            pCr[4] = (int8_t)(iCr);
            pCb[4] = (int8_t)(iCb);

            iCr = (s[(iPitch*8)+1] + s[(iPitch*9)+1] + 1)/2; // subsample vertically
            iCb = (s[(iPitch*8)+3] + s[(iPitch*9)+3] + 1)/2;
            pCr[32] = (int8_t)(iCr);
            pCb[32] = (int8_t)(iCb);
            iCr = (s[(iPitch*8)+17] + s[(iPitch*9)+17] + 1)/2; // subsample vertically
            iCb = (s[(iPitch*8)+19] + s[(iPitch*9)+19] + 1)/2;
            pCr[36] = (int8_t)(iCr);
            pCb[36] = (int8_t)(iCb);

            pCr++; pCb++;
            pY0 += 2; pY1 += 2; pY2 += 2; pY3 += 2;
            s += 4;
        } // for x
        pCr += 4; pCb += 4;
        pY0 += 8; pY1 += 8; pY2 += 8; pY3 += 8;
        s += (iPitch*2) - 16;
    } // for y
    pU32 = (uint32_t *)pMCUData;
    // all of the YUV values need to be adjusted +/-128, so XOR with 0x80
    for (x = 0; x<(6*16);x++) {
        pU32[0] ^= 0x80808080;
        pU32++;
    }
} /* JPEGSubSampleYUV422() */

void JPEGGetMCU22(unsigned char *pImage, JPEGE_IMAGE *pPage, int iPitch)
{
    int cx, cy, width, height;
    signed char *pMCUData = pPage->MCUc;
//    if (pPage->ucPixelType == JPEGE_PIXEL_RGB565)
//        pSrc = pImage + x*16*2 + (y * 16 * lsize);
//    else if (pPage->ucPixelType == JPEGE_PIXEL_RGB888)
//        pSrc = pImage + x*16*3 + (y * 16 * lsize);
//    else if (pPage->ucPixelType == JPEGE_PIXEL_ARGB8888)
//        pSrc = pImage + x*16*4 + (y * 16 * lsize);
//    else
//        return; // invalid bit depth
    //    pDest = pMCUData;
    cx = cy = 8;
    width = height = 16;
//    if (x*16 + width > pPage->iWidth)
//        width = pPage->iWidth & 15;
//    if (y*16 + height > pPage->iHeight)
//        height = pPage->iHeight & 15;
//    if (width < 8)
//        cx = width;
//    else
//        cx = 8;
//    if (height < 8)
//        cy = height;
//    else
//        cy = 8;
//    if (cy != 8 || cx != 8) // for edge MCUs, make sure all unused slots are 0
//        memset(pMCUData, 0, 6*64*sizeof(short));
    if (pPage->ucPixelType == JPEGE_PIXEL_YUV422) // U0 Y0 V0 Y1 U2 Y2 V2 Y3
    {
        JPEGSubSampleYUV422(pImage, pMCUData, iPitch);
    }
    else if (pPage->ucPixelType == JPEGE_PIXEL_RGB565 || pPage->ucPixelType == JPEGE_PIXEL_BGR565)
    {
        // upper left
        JPEGSubSample16(pImage, pMCUData, &pMCUData[DCTSIZE*4], &pMCUData[DCTSIZE*5], iPitch, cx, cy, pPage->ucPixelType);
        // upper right
        if (width > 8)
            JPEGSubSample16(pImage+8*2, &pMCUData[DCTSIZE*1], &pMCUData[4+DCTSIZE*4], &pMCUData[4+DCTSIZE*5], iPitch, width-8, cy, pPage->ucPixelType);
        if (height > 8)
        {
            // lower left
            JPEGSubSample16(pImage+8*iPitch, &pMCUData[DCTSIZE*2], &pMCUData[32+DCTSIZE*4], &pMCUData[32+DCTSIZE*5], iPitch, cx, height - 8, pPage->ucPixelType);
            // lower right
            if (width > 8)
                JPEGSubSample16(pImage+8*iPitch + 8*2, &pMCUData[DCTSIZE*3], &pMCUData[36+DCTSIZE*4], &pMCUData[36+DCTSIZE*5], iPitch, width - 8, height - 8, pPage->ucPixelType);
        }
    }
    else if (pPage->ucPixelType == JPEGE_PIXEL_RGB888 || pPage->ucPixelType == JPEGE_PIXEL_BGR888)
    {
        // upper left
        JPEGSubSample24(pImage, pMCUData, &pMCUData[DCTSIZE*4], &pMCUData[DCTSIZE*5], iPitch, cx, cy, pPage->ucPixelType);
        // upper right
        if (width > 8)
            JPEGSubSample24(pImage+8*3, &pMCUData[DCTSIZE*1], &pMCUData[4+DCTSIZE*4], &pMCUData[4+DCTSIZE*5], iPitch, width-8, cy, pPage->ucPixelType);
        if (height > 8)
        {
            // lower left
            JPEGSubSample24(pImage+8*iPitch, &pMCUData[DCTSIZE*2], &pMCUData[32+DCTSIZE*4], &pMCUData[32+DCTSIZE*5], iPitch, cx, height - 8, pPage->ucPixelType);
            // lower right
            if (width > 8)
                JPEGSubSample24(pImage+8*iPitch + 8*3, &pMCUData[DCTSIZE*3], &pMCUData[36+DCTSIZE*4], &pMCUData[36+DCTSIZE*5], iPitch, width - 8, height - 8, pPage->ucPixelType);
        }
    }
    else if (pPage->ucPixelType == JPEGE_PIXEL_ARGB8888 || pPage->ucPixelType == JPEGE_PIXEL_ABGR8888 || pPage->ucPixelType == JPEGE_PIXEL_RGBA8888 || pPage->ucPixelType == JPEGE_PIXEL_BGRA8888)
    {
        // upper left
        JPEGSubSample32(pImage, pMCUData, &pMCUData[DCTSIZE*4], &pMCUData[DCTSIZE*5], iPitch, cx, cy, pPage->ucPixelType);
        // upper right
        if (width > 8)
            JPEGSubSample32(pImage+8*4, &pMCUData[DCTSIZE*1], &pMCUData[4+DCTSIZE*4], &pMCUData[4+DCTSIZE*5], iPitch, width-8, cy, pPage->ucPixelType);
        if (height > 8)
        {
            // lower left
            JPEGSubSample32(pImage+8*iPitch, &pMCUData[DCTSIZE*2], &pMCUData[32+DCTSIZE*4], &pMCUData[32+DCTSIZE*5], iPitch, cx, height - 8, pPage->ucPixelType);
            // lower right
            if (width > 8)
                JPEGSubSample32(pImage+8*iPitch + 8*4, &pMCUData[DCTSIZE*3], &pMCUData[36+DCTSIZE*4], &pMCUData[36+DCTSIZE*5], iPitch, width - 8, height - 8, pPage->ucPixelType);
        }
    }
} /* JPEGGetMCU22() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGSample16()                                             *
 *                                                                          *
 *  PURPOSE    : Sample a 8x8 color block                                   *
 *                                                                          *
 ****************************************************************************/
void JPEGSample16(unsigned char *pSrc, signed char *pMCU, int lsize, int cx, int cy, uint8_t ucPixelType)
{
    int x, y;
    unsigned short us;
    unsigned short *pUS = (unsigned short *)pSrc;
    unsigned char cRed, cGreen, cBlue;
    int iY, iCr, iCb;
    
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++) // do 8x8 pixels
        {
            us = *pUS++;
            if (ucPixelType == JPEGE_PIXEL_RGB565)
            {
                cBlue = (unsigned char)(((us & 0x1f)<<3) | (us & 7));
                cGreen = (unsigned char)(((us & 0x7e0)>>3) | ((us & 0x60)>>5));
                cRed = (unsigned char)(((us & 0xf800)>>8) | ((us & 0x3800)>>11));
            }
            else
            {
                cBlue = (unsigned char)(((us & 0xf800)>>8) | ((us & 0x3800)>>11));
                cGreen = (unsigned char)(((us & 0x7e0)>>3) | ((us & 0x60)>>5));
                cRed = (unsigned char)(((us & 0x1f)<<3) | (us & 7));
            }
            iY = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            // store in the MCUs
            pMCU[64]  = (signed char)(iCb >> 12);
            pMCU[128]  = (signed char)(iCr >> 12);
            *pMCU++ = (signed char)iY;
        } // for x
        pMCU += 8 - cx;
        pUS += (lsize>>1) - cx;
    } // for y
    
} /* JPEGSample16() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGSample24()                                             *
 *                                                                          *
 *  PURPOSE    : Sample a 8x8 color block                                   *
 *                                                                          *
 ****************************************************************************/
void JPEGSample24(unsigned char *pSrc, signed char *pMCU, int lsize, int cx, int cy, uint8_t ucPixelType)
{
    int x;
    unsigned char cRed, cGreen, cBlue;
    int iY, iCr, iCb;
    int y;
    
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++) // do 8x8 pixels
        {
            if (ucPixelType == JPEGE_PIXEL_RGB888)
            {
                cRed = *pSrc++;
                cGreen = *pSrc++;
                cBlue = *pSrc++;
            }
            else
            {
                cBlue = *pSrc++;
                cGreen = *pSrc++;
                cRed = *pSrc++;
            }
            iY = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            // store in the MCUs
            pMCU[64]  = (signed char)(iCb >> 12);
            pMCU[128]  = (signed char)(iCr >> 12);
            *pMCU++ = (signed char)iY;
        } // for x
        pMCU += 8 - cx;
        pSrc += lsize - cx*3;
    } // for y
    
} /* JPEGSample24() */

void JPEGGetMCU11(unsigned char *pImage, JPEGE_IMAGE *pPage, int iPitch)
{
    int cx, cy;
    signed char *pMCUData = pPage->MCUc;
//    if (x*8 + 8 > pPage->iWidth)
//        cx = pPage->iWidth & 7;
//    else
        cx = 8;
//    if (y*8 + 8 > pPage->iHeight)
//        cy = pPage->iHeight & 7;
//    else
        cy = 8;
//    if (cy != 8 || cx != 8)
//        memset(pMCUData, 0, 3*64*sizeof(short)); // make sure unused pixels are 0
    if (pPage->ucPixelType == JPEGE_PIXEL_RGB888 || pPage->ucPixelType == JPEGE_PIXEL_BGR888)
        JPEGSample24(pImage, pMCUData, iPitch, cx, cy, pPage->ucPixelType);
    else if (pPage->ucPixelType == JPEGE_PIXEL_RGB565 || pPage->ucPixelType == JPEGE_PIXEL_BGR565)
        JPEGSample16(pImage, pMCUData, iPitch, cx, cy, pPage->ucPixelType);
    else // must be 32-bpp
        JPEGSample32(pImage, pMCUData, iPitch, cx, cy, pPage->ucPixelType);
    
} /* JPEGGetMCU11() */

void JPEGFDCT(signed char *pMCUSrc, signed short *pMCUDest)
{
    int iCol;
    int iRow;
    signed int tmp0,tmp1,tmp2,tmp3,tmp4,tmp5,tmp6,tmp7,tmp10,tmp11,tmp12,tmp13;
    signed int z1,z2,z3,z4,z5,z11,z13;
    signed char *s = pMCUSrc;
    signed short *d = pMCUDest;
    // do rows first
    for (iRow=0; iRow<64; iRow+=8, s += 8, d += 8)
    {
        tmp0 = s[0] + s[7];
        tmp7 = s[0] - s[7];
        tmp1 = s[1] + s[6];
        tmp6 = s[1] - s[6];
        tmp2 = s[2] + s[5];
        tmp5 = s[2] - s[5];
        tmp3 = s[3] + s[4];
        tmp4 = s[3] - s[4];
        // even part
        tmp10 = tmp0 + tmp3;
        tmp13 = tmp0 - tmp3;
        tmp11 = tmp1 + tmp2;
        tmp12 = tmp1 - tmp2;
        d[0] = (short)(tmp10 + tmp11);
        d[4] = (short)(tmp10 - tmp11);
        z1 = (((tmp12 + tmp13) * 181) >> 8);  // 181>>8 = 0.7071
        d[2] = (short)(tmp13 + z1);
        d[6] = (short)(tmp13 - z1);
        // odd part
        tmp10 = tmp4 + tmp5;
        tmp11 = tmp5 + tmp6;
        tmp12 = tmp6 + tmp7;
        z5 = ((tmp10 - tmp12) * 98); // 98 >>8 = 0.3826
        z2 = ((z5 + tmp10 * 139) >> 8); // 139 >>8 = 0.541196
        z4 = ((z5 + tmp12 * 334) >> 8); // 334 >>8 = 1.3065
        z3 = ((tmp11 * 181) >> 8);
        z11 = tmp7 + z3;
        z13 = tmp7 - z3;
        d[5] = (short)(z13 + z2);
        d[3] = (short)(z13 - z2);
        d[1] = (short)(z11 + z4);
        d[7] = (short)(z11 - z4);
    } // for each row
    // now do the columns
    d = pMCUDest;
    for (iCol=0; iCol < 8; iCol++, d++)
    {
        tmp0 = d[0*8] + d[7*8];
        tmp7 = d[0*8] - d[7*8];
        tmp1 = d[1*8] + d[6*8];
        tmp6 = d[1*8] - d[6*8];
        tmp2 = d[2*8] + d[5*8];
        tmp5 = d[2*8] - d[5*8];
        tmp3 = d[3*8] + d[4*8];
        tmp4 = d[3*8] - d[4*8];
        // even part
        tmp10 = tmp0 + tmp3;
        tmp13 = tmp0 - tmp3;
        tmp11 = tmp1 + tmp2;
        tmp12 = tmp1 - tmp2;
        d[0] = (short)(tmp10 + tmp11);
        d[4*8] = (short)(tmp10 - tmp11);
        z1 = (((tmp12 + tmp13) * 181) >> 8);
        d[2*8] = (short)(tmp13 + z1);
        d[6*8] = (short)(tmp13 - z1);
        // odd part
        tmp10 = tmp4 + tmp5;
        tmp11 = tmp5 + tmp6;
        tmp12 = tmp6 + tmp7;
        z5 = ((tmp10 - tmp12) * 98);
        z2 = ((z5 + tmp10 * 139) >> 8);
        z4 = ((z5 + tmp12 * 334) >> 8);
        z3 = (tmp11 * 181) >> 8;
        z11 = tmp7 + z3;
        z13 = tmp7 - z3;
        d[5*8] = (short)(z13 + z2);
        d[3*8] = (short)(z13 - z2);
        d[1*8] = (short)(z11 + z4);
        d[7*8] = (short)(z11 - z4);
    } // for each column
} /* JPEGFDCT() */

void FlushCode(PIL_CODE *pPC)
{
    unsigned char c;
   
    while (pPC->iLen > 0)
    {
        c = (unsigned char) (pPC->ulAcc >> (REGISTER_WIDTH-8));
        *pPC->pOut++ = c;
        if (c == 0xff) // stuffed 0
            *pPC->pOut++ = 0;
        pPC->ulAcc <<= 8;
        pPC->iLen -= 8;
    }
    pPC->iLen = 0;
} /* FlushCode() */

int JPEGAddMCU(JPEGE_IMAGE *pJPEG, JPEGENCODE *pEncode, uint8_t *pPixels, int iPitch)
{
    int bSparse;
    
    if (pEncode->y >= pJPEG->iHeight) {
        // the image is already complete or was not initialized properly
        pJPEG->iError = JPEGE_INVALID_PARAMETER;
        return JPEGE_INVALID_PARAMETER;
    }
    if (pJPEG->ucPixelType == JPEGE_PIXEL_GRAYSCALE) {
        JPEGGetMCU(pPixels, iPitch, pJPEG->MCUc);
        JPEGFDCT(pJPEG->MCUc, pJPEG->MCUs);
        bSparse = JPEGQuantize(pJPEG, pJPEG->MCUs, 0);
        pJPEG->iDCPred0 = JPEGEncodeMCU(0, pJPEG, pJPEG->MCUs, pJPEG->iDCPred0, bSparse);
        if (pEncode->x >= (pJPEG->iWidth - pEncode->cx)) { // end of the row?
            // Store the restart marker
            FlushCode(&pJPEG->pc);
            *(pJPEG->pc.pOut)++ = 0xff; // store restart marker
            *(pJPEG->pc.pOut)++ = (unsigned char) (0xd0 + (pJPEG->iRestart & 7));
            pJPEG->iRestart++;
            pJPEG->iDCPred0 = 0; // reset the DC predictor
            pEncode->x = 0;
            pEncode->y += pEncode->cy;
            if (pEncode->y >= pJPEG->iHeight && pJPEG->pOutput != NULL) {
                pJPEG->iDataSize = (int)(pJPEG->pc.pOut - pJPEG->pOutput);
            }
        } else {
            pEncode->x += pEncode->cx;
        } // grayscale
    } else { // color
        if (pJPEG->ucSubSample == JPEGE_SUBSAMPLE_444) {
            JPEGGetMCU11(pPixels, pJPEG, iPitch);
            JPEGFDCT(&pJPEG->MCUc[0*DCTSIZE], pJPEG->MCUs);
            // Y
            bSparse = JPEGQuantize(pJPEG, pJPEG->MCUs, 0);
            pJPEG->iDCPred0 = JPEGEncodeMCU(0, pJPEG, pJPEG->MCUs, pJPEG->iDCPred0, bSparse);
            JPEGFDCT(&pJPEG->MCUc[1*DCTSIZE], pJPEG->MCUs);
            // Cb
            bSparse = JPEGQuantize(pJPEG, pJPEG->MCUs, 1);
            pJPEG->iDCPred1 = JPEGEncodeMCU(1, pJPEG, pJPEG->MCUs, pJPEG->iDCPred1, bSparse);
            JPEGFDCT(&pJPEG->MCUc[2*DCTSIZE], pJPEG->MCUs);
            // Cr
            bSparse = JPEGQuantize(pJPEG, pJPEG->MCUs, 1);
            pJPEG->iDCPred2 = JPEGEncodeMCU(1, pJPEG, pJPEG->MCUs, pJPEG->iDCPred2, bSparse);
        } else { // must be 420
            JPEGGetMCU22(pPixels, pJPEG, iPitch);
            JPEGFDCT(&pJPEG->MCUc[0*DCTSIZE], pJPEG->MCUs); // Y0
            bSparse = JPEGQuantize(pJPEG, pJPEG->MCUs, 0);
            pJPEG->iDCPred0 = JPEGEncodeMCU(0, pJPEG, pJPEG->MCUs, pJPEG->iDCPred0, bSparse);
            JPEGFDCT(&pJPEG->MCUc[1*DCTSIZE], pJPEG->MCUs); // Y1
            bSparse = JPEGQuantize(pJPEG, pJPEG->MCUs, 0);
            pJPEG->iDCPred0 = JPEGEncodeMCU(0, pJPEG, pJPEG->MCUs, pJPEG->iDCPred0, bSparse);
            JPEGFDCT(&pJPEG->MCUc[2*DCTSIZE], pJPEG->MCUs); // Y2
            bSparse = JPEGQuantize(pJPEG, pJPEG->MCUs, 0);
            pJPEG->iDCPred0 = JPEGEncodeMCU(0, pJPEG, pJPEG->MCUs, pJPEG->iDCPred0, bSparse);
            JPEGFDCT(&pJPEG->MCUc[3*DCTSIZE], pJPEG->MCUs); // Y3
            bSparse = JPEGQuantize(pJPEG, pJPEG->MCUs, 0);
            pJPEG->iDCPred0 = JPEGEncodeMCU(0, pJPEG, pJPEG->MCUs, pJPEG->iDCPred0, bSparse);
            JPEGFDCT(&pJPEG->MCUc[4*DCTSIZE], pJPEG->MCUs); // Cb
            bSparse = JPEGQuantize(pJPEG, pJPEG->MCUs, 1);
            pJPEG->iDCPred1 = JPEGEncodeMCU(1, pJPEG, pJPEG->MCUs, pJPEG->iDCPred1, bSparse);
            JPEGFDCT(&pJPEG->MCUc[5*DCTSIZE], pJPEG->MCUs); // Cr
            bSparse = JPEGQuantize(pJPEG, pJPEG->MCUs, 1);
            pJPEG->iDCPred2 = JPEGEncodeMCU(1, pJPEG, pJPEG->MCUs, pJPEG->iDCPred2, bSparse);
        } // 420 subsample
        if (pEncode->x >= (pJPEG->iWidth - pEncode->cx)) { // end of the row?
            // Store the restart marker
            FlushCode(&pJPEG->pc);
            *(pJPEG->pc.pOut)++ = 0xff; // store restart marker
            *(pJPEG->pc.pOut)++ = (unsigned char) (0xd0 + (pJPEG->iRestart & 7));
            pJPEG->iRestart++;
            pJPEG->iDCPred0 = pJPEG->iDCPred1 = pJPEG->iDCPred2 = 0; // reset the DC predictors
            pEncode->x = 0;
            pEncode->y += pEncode->cy;
            if (pEncode->y >= pJPEG->iHeight && pJPEG->pOutput) {
                pJPEG->iDataSize = (int)(pJPEG->pc.pOut - pJPEG->pOutput);
            }
        } else {
            pEncode->x += pEncode->cx;
        } // grayscale
    }
    if (pJPEG->pc.pOut >= pJPEG->pHighWater) { // out of space or need to write incremental buffer
        if (pJPEG->pOutput) { // the user-supplied buffer is not big enough
            pJPEG->iError = JPEGE_NO_BUFFER;
            return JPEGE_NO_BUFFER;
        } else { // write current block of data
            int iLen = (int)(pJPEG->pc.pOut - pJPEG->ucFileBuf);
            pJPEG->pfnWrite(&pJPEG->JPEGFile, pJPEG->ucFileBuf, iLen);
            pJPEG->iDataSize += iLen;
            pJPEG->pc.pOut = pJPEG->ucFileBuf;
        }
    }
    return JPEGE_SUCCESS;
} /* JPEGAddMCU() */

int JPEGAddFrame(JPEGE_IMAGE *pJPEG, JPEGENCODE *pEncode, uint8_t *pPixels, int iPitch)
{
int x, y;
uint8_t *s;
int rc = JPEGE_SUCCESS;
int iBPMCU;

    iBPMCU = pEncode->cx;
    switch (pJPEG->ucPixelType) {
        case JPEGE_PIXEL_GRAYSCALE:
           break; // 1 byte per pixel
        case JPEGE_PIXEL_RGB565:
        case JPEGE_PIXEL_BGR565:
           iBPMCU *= 2;
           break;
        case JPEGE_PIXEL_RGB888:
        case JPEGE_PIXEL_BGR888:
           iBPMCU *= 3;
           break;
        case JPEGE_PIXEL_ARGB8888:
        case JPEGE_PIXEL_ABGR8888:
        case JPEGE_PIXEL_RGBA8888:
        case JPEGE_PIXEL_BGRA8888:
           iBPMCU *= 4;
           break;
        case JPEGE_PIXEL_YUV422:
           iBPMCU *= 2; // average 2 bytes per pixel
           break;
    }
    for (y = 0; y < pJPEG->iMCUHeight && rc == JPEGE_SUCCESS; y++) {
        s = &pPixels[y * pEncode->cy * iPitch];
        for (x = 0; x<pJPEG->iMCUWidth && rc == JPEGE_SUCCESS; x++) {
            rc = JPEGAddMCU(pJPEG, pEncode, s, iPitch);
            s += iBPMCU;
        } // for x
    } // for y
    return rc;
} /* JPEGAddFrame() */

